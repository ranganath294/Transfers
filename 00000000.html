// Helper function to create expand/collapse button for inner table
function createInnerTableExpandButton(isExpanded = false) {
    const btn = document.createElement('button');
    btn.innerHTML = isExpanded 
        ? `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#328AA4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-minus-circle">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="12" x2="12" y2="12"></line>
          </svg>`
        : `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#328AA4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus-circle">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="16"></line>
            <line x1="8" y1="12" x2="16" y2="12"></line>
          </svg>`;
    
    btn.className = 'inner-table-expand-btn';
    btn.style.cssText = `
        background: none;
        border: none;
        cursor: pointer;
        padding: 4px;
        transition: transform 0.2s ease;
    `;
    
    return btn;
}

// Calculation function for inner table 1
function calculateInnerTable1Metrics(phaseData) {
    // This function will process the detailed metrics for a specific phase
    const detailedMetrics = [];

    // Check if coverage_types exists and has entries
    if (phaseData.coverage_types) {
        phaseData.coverage_types.forEach(coverageType => {
            // Create an entry for each coverage type
            detailedMetrics.push({
                coverage_type: coverageType.coverage_type,
                metrics: coverageType.metrics,
                unique_cr_list: coverageType.unique_cr_list || [],
                unique_cr_count: coverageType.unique_cr_list ? coverageType.unique_cr_list.length : 0,
                unique_jira_list: coverageType.unique_jira_list || [],
                unique_jira_count: coverageType.unique_jira_list ? coverageType.unique_jira_list.length : 0
            });
        });
    } else {
        // If no coverage types, use the phase-level metrics
        detailedMetrics.push({
            coverage_type: 'All',
            metrics: phaseData.metrics,
            unique_cr_list: phaseData.unique_cr_list || [],
            unique_cr_count: phaseData.unique_cr_list ? phaseData.unique_cr_list.length : 0,
            unique_jira_list: phaseData.unique_jira_list || [],
            unique_jira_count: phaseData.unique_jira_list ? phaseData.unique_jira_list.length : 0
        });
    }

    return detailedMetrics;
}

function renderInnerTable1(phaseData, targetRow) {
    // Create inner table
    const innerTable = document.createElement('table');
    innerTable.className = 'coverage-table inner-table-1';
    innerTable.style.width = '100%';

    // Create header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const headers = [
        'Coverage Type', 
        'Total TCs',
        'Coverage', 'Coverage %',
        'Passed', 'Pass %',
        'Failed', 'Fail %',
        'Blocked', 'Block %',
        'Unique CRs',
        'Unique JIRAs'
    ];
    headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    innerTable.appendChild(thead);

    // Create body
    const tbody = document.createElement('tbody');
    
    // Calculate detailed metrics
    const detailedMetrics = calculateInnerTable1Metrics(phaseData);

    detailedMetrics.forEach(entry => {
        const tr = document.createElement('tr');

        const cells = [
            entry.coverage_type,
            entry.metrics.total,
            entry.metrics.coverage,
            formatPercentage(entry.metrics.coverage_percentage),
            entry.metrics.passed,
            formatPercentage(entry.metrics.passed_percentage),
            entry.metrics.failed,
            formatPercentage(entry.metrics.failed_percentage),
            entry.metrics.blocked,
            formatPercentage(entry.metrics.blocked_percentage)
        ];

        cells.forEach(cellData => {
            const td = document.createElement('td');
            td.textContent = cellData;
            tr.appendChild(td);
        });

        // Unique CRs column
        const crTd = document.createElement('td');
        crTd.innerHTML = formatLongList(entry.unique_cr_list, entry.unique_cr_count);
        tr.appendChild(crTd);

        // Unique JIRAs column
        const jiraTd = document.createElement('td');
        jiraTd.innerHTML = formatLongList(entry.unique_jira_list, entry.unique_jira_count);
        tr.appendChild(jiraTd);

        tbody.appendChild(tr);
    });

    innerTable.appendChild(tbody);

    // Create a new row to span across all columns
    const innerTableRow = document.createElement('tr');
    const innerTableCell = document.createElement('td');
    innerTableCell.setAttribute('colspan', '13');
    innerTableCell.appendChild(innerTable);
    innerTableRow.appendChild(innerTableCell);
    innerTableRow.classList.add('inner-table-1-row');

    // Insert the inner table row after the clicked row
    targetRow.insertAdjacentElement('afterend', innerTableRow);

    // Add event listeners for "more" links in the inner table
    innerTableCell.addEventListener('click', (e) => {
        if (e.target.classList.contains('show-more-list')) {
            e.preventDefault();
            const title = e.target.getAttribute('data-title');
            const list = JSON.parse(decodeURIComponent(e.target.getAttribute('data-list')));
            createListModal(title, list);
        }
    });
}

// Modify renderCumulativeTable to add expand functionality
function renderCumulativeTable(data, targetElementId) {
    // ... [previous implementation remains the same]

    // Modify expand button event listener
    expandBtn.addEventListener('click', (event) => {
        const btn = event.currentTarget;
        const parentRow = btn.closest('tr');
        const spIndex = parentRow.dataset.spIndex;
        const phaseIndex = parentRow.dataset.phaseIndex;

        // Check if inner table is already expanded
        const existingInnerTable = parentRow.nextElementSibling;
        const isCurrentlyExpanded = existingInnerTable && existingInnerTable.classList.contains('inner-table-1-row');

        if (isCurrentlyExpanded) {
            // Collapse
            existingInnerTable.remove();
            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#328AA4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus-circle">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>`;
        } else {
            // Expand
            const phaseData = data[0].phases[phaseIndex];
            renderInnerTable1(phaseData, parentRow);
            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#328AA4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-minus-circle">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="12" x2="12" y2="12"></line>
            </svg>`;
        }
    });

    // ... [rest of the previous implementation]
}