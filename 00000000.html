// Add event listener for Graphs button
graphsInput.addEventListener('change', async () => {
    if (graphsInput.checked) {
        console.log('Graphs clicked');
        const spSelect = document.getElementById('sp_name');
        const selectedSp = spSelect.value;
        const selectedTeam = document.querySelector('input[name="team-filter"]:checked').value;

        if (!selectedSp) {
            addAlert('danger', 'Please select an SP first');
            return;
        }

        contentContainer.innerHTML = ''; // Clear the content container
        
        // Create phase filter buttons for graphs view
        const phaseFilterContainer = document.createElement('div');
        phaseFilterContainer.className = 'mb-3'; // Add margin bottom for spacing

        // Create button group for phase filters
        const graphPhaseButtonGroup = document.createElement('div');
        graphPhaseButtonGroup.className = 'btn-group';
        graphPhaseButtonGroup.setAttribute('role', 'group');
        graphPhaseButtonGroup.setAttribute('aria-label', 'Phase filters');

        // Create phase filter buttons
        const phases = ['all', 'ES', 'FC', 'CS'];
        phases.forEach(phase => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = `btn btn-outline-primary graph-phase-filter ${phase === 'all' ? 'active' : ''}`;
            button.setAttribute('data-phase', phase);
            button.textContent = phase === 'all' ? 'All Phases' : phase;
            graphPhaseButtonGroup.appendChild(button);
        });
        
        phaseFilterContainer.appendChild(graphPhaseButtonGroup);
        contentContainer.appendChild(phaseFilterContainer);
        
        // Add event listeners for phase filter buttons
        graphPhaseButtonGroup.addEventListener('click', async (e) => {
            if (e.target.classList.contains('graph-phase-filter')) {
                // Remove active class from all buttons
                graphPhaseButtonGroup.querySelectorAll('.graph-phase-filter').forEach(btn => btn.classList.remove('active'));
                // Add active class to the clicked button
                e.target.classList.add('active');
                // Get the selected phase
                const selectedPhase = e.target.getAttribute('data-phase');
                
                // Remove any existing graph images
                const existingImages = contentContainer.querySelectorAll('img');
                existingImages.forEach(img => img.remove());
                
                // Remove any "no graph" message
                const existingMessages = contentContainer.querySelectorAll('.text-center.mt-3');
                existingMessages.forEach(msg => msg.remove());
                
                // Create loading indicator
                const loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'text-center mt-3';
                loadingIndicator.textContent = 'Loading graphs...';
                contentContainer.appendChild(loadingIndicator);
                
                // Fetch and render graphs with the selected phase
                await fetchAndRenderGraphs(selectedSp, selectedTeam, selectedPhase, contentContainer);
                
                // Remove loading indicator
                loadingIndicator.remove();
            }
        });
        
        // Fetch and render graphs with default 'all' phase
        await fetchAndRenderGraphs(selectedSp, selectedTeam, 'all', contentContainer);
    }
});

// Function to fetch and render graphs based on selected parameters
async function fetchAndRenderGraphs(selectedSp, selectedTeam, selectedPhase, container) {
    const params = new URLSearchParams();
    params.append('sp_name', selectedSp);
    params.append('team', selectedTeam);
    params.append('phase', selectedPhase);
    
    try {
        const response = await fetch(`{% url 'cst_reporting_views:get_graph_image' %}?${params.toString()}`);
        if (!response.ok) throw new Error('Network response was not ok');

        const data = await response.json();
        const images = data.images;

        if (images.length === 0) {
            const noGraphMessage = document.createElement('div');
            noGraphMessage.textContent = 'Graph not available for selected phase';
            noGraphMessage.className = 'text-center mt-3';
            container.appendChild(noGraphMessage);
        } else {
            // Create a container for the images
            const imageContainer = document.createElement('div');
            imageContainer.className = 'graph-images-container';
            
            images.forEach((imageBase64, index) => {
                // Create an image element
                const img = document.createElement('img');
                img.className = 'img-fluid mb-3'; // Add Bootstrap classes for responsive image and margin
                img.alt = `Graph Image ${index + 1}`;

                // Set the src attribute of the image to the base64 data
                img.src = `data:image/jpg;base64,${imageBase64}`;

                // Append the image to the image container
                imageContainer.appendChild(img);
            });
            
            // Append the image container to the main container
            container.appendChild(imageContainer);
        }
    } catch (error) {
        console.error('Error fetching graph images:', error);
        addAlert('danger', `Error fetching graph images. Please try again.\n ${error}`);
    }
}