// Update the OptimizedSelect class
class OptimizedSelect {
    constructor(originalSelect, options = {}) {
        if(originalSelect.dataset.initialized){
            return;
        }

        this.originalSelect = originalSelect;
        this.options = options;
        this.itemHeight = 35;
        this.visibleItems = 8;
        this.allOptions = Array.from(originalSelect.options).map(opt => ({
            value: opt.value,
            label: opt.text
        }));
        this.isOpen = false;

        originalSelect.dataset.initialized = 'true';
    
        this.init();

        // Add validation styling to button
        this.button.classList.add('form-select');
        
        // Add change event listener for validation
        this.originalSelect.addEventListener('change', () => {
            validateInput(this.originalSelect);
        });

        // Store instance in the select element
        originalSelect.optimizedSelect = this;
    }

    // ... (keep existing methods)

    focus() {
        // Focus the button and open the dropdown
        this.button.focus();
        this.openDropdown();
        
        // Scroll the dropdown into view if needed
        this.dropdown.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    openDropdown() {
        this.isOpen = true;
        this.dropdown.style.display = 'block';
        this.searchInput.value = '';
        this.searchInput.focus();
        this.filterAndRenderOptions();
    }

    // ... (keep other existing methods)
}

// Update the handleFormSubmission function
function handleFormSubmission(event) {
    event.preventDefault();

    const form = event.target;
    const formElements = Array.from(form.elements).filter(element => 
        element.name && 
        element.name !== 'csrfmiddlewaretoken' && 
        ['INPUT', 'TEXTAREA', 'SELECT'].includes(element.tagName)
    );

    let isValid = true;
    let firstInvalidInput = null;

    // Validate all inputs
    formElements.forEach(element => {
        if (!validateInput(element)) {
            isValid = false;
            if (!firstInvalidInput) {
                firstInvalidInput = element;
            }
        }
    });

    if (!isValid) {
        // Special handling for the filter_sp_name field
        const filterSpSelect = document.querySelector('select[name="filter_sp_name"]');
        if (filterSpSelect && filterSpSelect.classList.contains('is-invalid')) {
            // Use the stored OptimizedSelect instance
            if (filterSpSelect.optimizedSelect) {
                filterSpSelect.optimizedSelect.focus();
            }
            return;
        }

        // Handle other invalid inputs
        if (firstInvalidInput) {
            if (firstInvalidInput.tagName === 'SELECT') {
                const optimizedInstance = firstInvalidInput.optimizedSelect;
                if (optimizedInstance) {
                    optimizedInstance.focus();
                }
            } else {
                firstInvalidInput.focus();
            }
        }
        return;
    }

    // Rest of your form submission logic...
}

// Update the validateInput function for SELECT elements
function validateInput(input) {
    if (input.tagName === 'SELECT') {
        const validationMessage = document.getElementById(`${input.id}-validation`) || 
            createValidationMessageForDropdown(input);
            
        if (!input.value) {
            input.classList.add('is-invalid');
            input.classList.remove('is-valid');
            validationMessage.textContent = 'Please select an option';
            validationMessage.style.display = 'block';
            
            // Update the OptimizedSelect button styling
            const customButton = input.nextElementSibling?.querySelector('.optimized-select-button');
            if (customButton) {
                customButton.classList.add('is-invalid');
                customButton.classList.remove('is-valid');
            }
            return false;
        }
        
        input.classList.remove('is-invalid');
        input.classList.add('is-valid');
        validationMessage.style.display = 'none';
        
        // Update the OptimizedSelect button styling
        const customButton = input.nextElementSibling?.querySelector('.optimized-select-button');
        if (customButton) {
            customButton.classList.remove('is-invalid');
            customButton.classList.add('is-valid');
        }
        return true;
    }

    // Rest of your validation logic for other input types...
}