function calculateInnerTable1Metrics(phaseData, tableData, selectedTeam) {
    // Find the SP and team in the original table data
    const spData = tableData.find(sp => sp.sp_name === phaseData.sp_name);
    if (!spData) return [];

    // Find the specific team data
    const teamData = spData.teams.find(team => team.team_name === selectedTeam);
    if (!teamData) return [];

    // Filter phases that match the current phase and have coverage types
    const matchingPhases = teamData.phases.filter(
        phase => phase.phase === phaseData.phase && phase.coverage_types
    );

    // Process coverage types
    const detailedMetrics = [];
    matchingPhases.forEach(phase => {
        if (phase.coverage_types) {
            phase.coverage_types.forEach(coverageType => {
                detailedMetrics.push({
                    coverage_type: coverageType.coverage_type,
                    metrics: coverageType.metrics,
                    unique_cr_list: coverageType.unique_cr_list || [],
                    unique_cr_count: coverageType.unique_cr_list ? coverageType.unique_cr_list.length : 0,
                    unique_jira_list: coverageType.unique_jira_list || [],
                    unique_jira_count: coverageType.unique_jira_list ? coverageType.unique_jira_list.length : 0
                });
            });
        }
    });

    return detailedMetrics;
}

// Modify renderInnerTable1 to pass additional parameters
function renderInnerTable1(phaseData, targetRow, tableData) {
    // Get the selected team from the team filter
    const selectedTeam = document.querySelector('input[name="team-filter"]:checked').value;

    // Calculate detailed metrics using the full table data
    const detailedMetrics = calculateInnerTable1Metrics(phaseData, tableData, selectedTeam);

    // Create inner table
    const innerTable = document.createElement('table');
    innerTable.className = 'coverage-table inner-table-1';
    innerTable.style.width = '100%';

    // Create header (same as before)
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const headers = [
        'Coverage Type', 
        'Total TCs',
        'Coverage', 'Coverage %',
        'Passed', 'Pass %',
        'Failed', 'Fail %',
        'Blocked', 'Block %',
        'Unique CRs',
        'Unique JIRAs'
    ];
    headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    innerTable.appendChild(thead);

    // Create body
    const tbody = document.createElement('tbody');
    
    detailedMetrics.forEach(entry => {
        const tr = document.createElement('tr');

        const cells = [
            entry.coverage_type,
            entry.metrics.total,
            entry.metrics.coverage,
            formatPercentage(entry.metrics.coverage_percentage),
            entry.metrics.passed,
            formatPercentage(entry.metrics.passed_percentage),
            entry.metrics.failed,
            formatPercentage(entry.metrics.failed_percentage),
            entry.metrics.blocked,
            formatPercentage(entry.metrics.blocked_percentage)
        ];

        cells.forEach(cellData => {
            const td = document.createElement('td');
            td.textContent = cellData;
            tr.appendChild(td);
        });

        // Unique CRs column
        const crTd = document.createElement('td');
        crTd.innerHTML = formatLongList(entry.unique_cr_list, entry.unique_cr_count);
        tr.appendChild(crTd);

        // Unique JIRAs column
        const jiraTd = document.createElement('td');
        jiraTd.innerHTML = formatLongList(entry.unique_jira_list, entry.unique_jira_count);
        tr.appendChild(jiraTd);

        tbody.appendChild(tr);
    });

    innerTable.appendChild(tbody);

    // Create a new row to span across all columns
    const innerTableRow = document.createElement('tr');
    const innerTableCell = document.createElement('td');
    innerTableCell.setAttribute('colspan', '13');
    innerTableCell.appendChild(innerTable);
    innerTableRow.appendChild(innerTableCell);
    innerTableRow.classList.add('inner-table-1-row');

    // Insert the inner table row after the clicked row
    targetRow.insertAdjacentElement('afterend', innerTableRow);

    // Add event listeners for "more" links in the inner table
    innerTableCell.addEventListener('click', (e) => {
        if (e.target.classList.contains('show-more-list')) {
            e.preventDefault();
            const title = e.target.getAttribute('data-title');
            const list = JSON.parse(decodeURIComponent(e.target.getAttribute('data-list')));
            createListModal(title, list);
        }
    });
}

// Modify renderCumulativeTable to pass table data
function renderCumulativeTable(data, targetElementId) {
    // Store tableData as a variable in the scope
    let tableData = null;

    // Existing code for rendering the table...

    // Modify expand button event listener
    expandBtn.addEventListener('click', (event) => {
        const btn = event.currentTarget;
        const parentRow = btn.closest('tr');
        const spIndex = parentRow.dataset.spIndex;
        const phaseIndex = parentRow.dataset.phaseIndex;

        // Check if inner table is already expanded
        const existingInnerTable = parentRow.nextElementSibling;
        const isCurrentlyExpanded = existingInnerTable && existingInnerTable.classList.contains('inner-table-1-row');

        if (isCurrentlyExpanded) {
            // Collapse
            existingInnerTable.remove();
            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#328AA4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus-circle">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>`;
        } else {
            // Expand
            const phaseData = {
                ...data[0].phases[phaseIndex],
                sp_name: document.getElementById('sp_name').value // Get current SP name
            };
            renderInnerTable1(phaseData, parentRow, tableData);
            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#328AA4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-minus-circle">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="12" x2="12" y2="12"></line>
            </svg>`;
        }
    });

    // Capture tableData when fetching
    const originalFetch = async function() {
        try {
            const response = await fetch(`{% url 'cst_reporting_views:coverage_report' %}?${params.toString()}`);
            if (!response.ok) throw new Error('Network response was not ok');
            const responseData = await response.json();
            tableData = responseData["table_data"];
            // Rest of the existing fetch logic...
        } catch (error) {
            console.error('Error fetching data:', error);
            alert('Error fetching data. Please try again.');
        } finally {
            setLoadingState(false);
        }
    };
}