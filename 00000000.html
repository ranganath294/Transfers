def add_table_to_slide(slide, data, merge_info, left, top, width, height):

    rows = len(data)

    cols = len(data[0])

    table_shape = slide.shapes.add_table(rows, cols, left, top, width, height)

    table = table_shape.table

    

    # Define proportional column widths

    column_widths = [

        Inches(0.7),  # Test Team

        Inches(0.9),  # Date

        Inches(0.6),  # Phase

        Inches(0.8),  # Coverage Type

        Inches(0.7),  # Total TCs

        Inches(0.7),  # Coverage

        Inches(0.7),  # Coverage %

        Inches(0.7),  # Passed

        Inches(0.7),  # Pass %

        Inches(0.7),  # Failed

        Inches(0.7),  # Fail %

        Inches(0.7),  # Blocked

        Inches(0.7),  # Block %

        Inches(0.7)   # Unique Issues

    ]

    

    # Set column widths

    for i, col_width in enumerate(column_widths):

        table.columns[i].width = col_width

    

    # Set row heights

    for row in table.rows:

        row.height = Inches(0.4)  # Adjust row height as needed

    

    # Fill the table

    for i, row_data in enumerate(data):

        for j, cell_data in enumerate(row_data):

            cell = table.cell(i, j)

            if cell.text == "":

                cell.text = str(cell_data)

            para = cell.text_frame.paragraphs[0]

            para.font.size = Pt(10)

            para.font.color.rgb = RGBColor(0, 0, 0)

    

    # Apply merging

    for merge in merge_info:

        start_row, end_row, col_idx = merge

        if not is_range_merged(table, start_row, end_row, col_idx):

            table.cell(start_row, col_idx).merge(table.cell(end_row, col_idx))

    

    return table

# Helper function to check if a range is already merged

def is_range_merged(table, start_row, end_row, col_idx):

    for i in range(start_row, end_row + 1):

        cell = table.cell(i, col_idx)

        if cell.is_merge_origin:

            return True

    return False

# Helper function to prepare table data

def prepare_table_data(teams):

    table_data = []

    merge_info = []

    header = [

        'Test Team', 'Date', 'Phase', 'Coverage Type', 'Total TCs',

        'Coverage', 'Coverage %', 'Passed', 'Pass %', 'Failed', 'Fail %',

        'Blocked', 'Block %', 'Unique Issues'

    ]

    table_data.append(header)

    current_row = 1  # since 0 is header

    

    for team in teams:

        team_name = team['team_name']

        team_start_row = current_row

        team_row_count = 0

        

        for phase in team['phases']:

            phase_name = phase['phase']

            phase_date = phase['date']

            coverage_types = phase['coverage_types']

            unique_issue_count = phase['unique_issue_count']

            phase_start_row = current_row

            phase_row_count = 0

            

            for ct in coverage_types:

                ct_metrics = ct['metrics']

                row = [

                    team_name if current_row == team_start_row else "",  # Only set team name for the first row of the team

                    phase_date if current_row == phase_start_row else "",  # Only set phase date for the first row of the phase

                    phase_name if current_row == phase_start_row else "",  # Only set phase name for the first row of the phase

                    ct['coverage_type'],

                    ct_metrics['total'], ct_metrics['coverage'], f"{ct_metrics['coverage_percentage']:.2f}%",

                    ct_metrics['passed'], f"{ct_metrics['passed_percentage']:.2f}%",

                    ct_metrics['failed'], f"{ct_metrics['failed_percentage']:.2f}%",

                    ct_metrics['blocked'], f"{ct_metrics['blocked_percentage']:.2f}%",

                    unique_issue_count

                ]

                table_data.append(row)

                current_row += 1

                phase_row_count += 1

                team_row_count += 1

            

            # Merge phase columns

            if phase_row_count > 1:  # Only merge if there are multiple rows for this phase

                merge_info.append((phase_start_row, current_row - 1, 1))  # Date

                merge_info.append((phase_start_row, current_row - 1, 2))  # Phase

        

        # Merge team column

        if team_row_count > 1:  # Only merge if there are multiple rows for this team

            merge_info.append((team_start_row, current_row - 1, 0))  # Team

    

    return table_data, merge_info

# Helper function to add a slide with a table

def add_slide_with_table(prs, title_text, data, merge_info, left, top, width, height):

    slide_layout = prs.slide_layouts[5]  # Title and Content slide

    slide = prs.slides.add_slide(slide_layout)

    title = slide.shapes.title

    title.text = title_text

    add_table_to_slide(slide, data, merge_info, left, top, width, height)

# Function to create slides based on configuration

def add_coverage_report_slides(prs, coverage_summary_data, selected_sp, selected_teams=None, selected_phases=None):

    for sp in coverage_summary_data:

        sp_name = sp['sp_name']

        teams = sp['teams']

        

        # Filter teams and phases based on selection

        filtered_teams = []

        for team in teams:

            if selected_teams is None or team['team_name'] in selected_teams:

                filtered_phases = []

                for phase in team['phases']:

                    if selected_phases is None or phase['phase'] in selected_phases:

                        filtered_phases.append(phase)

                if filtered_phases:

                    filtered_teams.append({'team_name': team['team_name'], 'phases': filtered_phases})

        

        # Prepare data for each team and phase combination

        for team in filtered_teams:

            team_name = team['team_name']

            for phase in team['phases']:

                phase_name = phase['phase']

                phase_date = phase['date']

                coverage_types = phase['coverage_types']

                unique_issue_count = phase['unique_issue_count']

                phase_data, phase_merge_info = prepare_table_data([{'team_name': team_name, 'phases': [phase]}])

                if phase_data:  # Only add a table if there is data

                    title_text = f"{sp_name} {team_name} {phase_name}"

                    add_slide_with_table(prs, title_text, phase_data, phase_merge_info, Inches(0.0), Inches(2), Inches(11.6), Inches(0.4 * len(phase_data)))

def calculate_test_group_percentages_data(selected_sp, selected_team, selected_phase, coverage_summary_data):

    sp_data = None

    for sp in coverage_summary_data:

        if sp['sp_name'] == selected_sp:

            sp_data = sp

            break

    if not sp_data:

        return []

    team_data = None

    for team in sp_data['teams']:

        if team['team_name'] == selected_team:

            team_data = team

            break

    if not team_data:

        return []

    phase_data = None

    for phase in team_data['phases']:

        if phase['phase'] == selected_phase:

            phase_data = phase

            break

    if not phase_data or not phase_data.get('test_group_level_percentages'):

        return []

    test_group_percentages = []

    for test_group, test_group_data in phase_data['test_group_level_percentages'].items():

        test_group_percentages.append({

            'test_group': test_group,

            'test_group_percentage': test_group_data['test_group_percentage']

        })

    test_group_percentages.sort(key=lambda x: x['test_group_percentage'], reverse=True)

    

    return test_group_percentages

def create_cr_verification_data_dict(selected_sp, required_columns=None):

    teams_list = ["BT", "WLAN"]

    phases_list = ["ES", "FC", "CS"]

    all_sp_crs = {}

    

    cr_verification_data_folder = os.path.join(ConfigPaths.ref_dir, "cr_verification_data")

    filename = f"{selected_sp}_cr_verification_data.csv"

    file_path = os.path.join(cr_verification_data_folder, filename)

    # Check if the file exists

    if not os.path.exists(file_path):

        print(f"File {filename} does not exist.")

    

    sp_cr_df = pd.read_csv(file_path, low_memory=False)

    

    for team in teams_list:

        if team not in all_sp_crs:

            all_sp_crs[team] = {}

        

        for phase in phases_list:

            # Filter the DataFrame for the specific team and phase

            filtered_df = sp_cr_df[(sp_cr_df['For Test Team'] == team) & (sp_cr_df['For Test Phase'] == phase)]

            print(team, phase)

            # Select only the required columns

            required_columns = ["CR_ID", "DupCR", "Title", "CreatedOn", "Status", "Subsystem", "SIName", "ReadyDate", "FA", "Assignee", "Reporter", "CR_Age_Days", "Failed_Blocked_TCs", "Notes"]

            filtered_df = filtered_df[required_columns]

            # Convert all required columns to object type

            for column in required_columns:

                filtered_df[column] = filtered_df[column].astype(object)

            # Replace NaN values with None

            filtered_df = filtered_df.where(pd.notnull(filtered_df), None)

            

            # Convert the DataFrame to a list of dictionaries

            data_list = filtered_df.to_dict(orient='records')

            

            # Store the data in the dictionary

            all_sp_crs[team][phase] = data_list

    

    return all_sp_crs

def create_scrum_sheet_data(cr_verification_data, coverage_summary_data):

    if not cr_verification_data:

        print('cr_verification_data is not available.')

        return

    

    if not coverage_summary_data:

        print('coverage_summary_data is not available.')

        return

    # Initialize an empty dictionary for scrum_sheet_data

    scrum_sheet_data = {}

    # Iterate over each SP in coverage_summary_data

    for sp in coverage_summary_data:

        for team in sp['teams']:

            if team['team_name'] not in scrum_sheet_data:

                scrum_sheet_data[team['team_name']] = {}

            for phase in team['phases']:

                if phase['phase'] not in scrum_sheet_data[team['team_name']]:

                    scrum_sheet_data[team['team_name']][phase['phase']] = set()  # Use a set to store unique CR IDs

                if 'coverage_types' in phase:

                    for coverage_type in phase['coverage_types']:

                        unique_cr_list = coverage_type['unique_cr_list']

                        for cr in unique_cr_list:

                            # Extract the numeric part of the CR ID

                            cr_id_numeric = cr.replace('CR-', '')

                            # Find the CR in cr_verification_data

                            cr_data = next(

                                (item for item in cr_verification_data.get(team['team_name'], {}).get(phase['phase'], [])

                                 if item['CR_ID'] == int(cr_id_numeric)),

                                None

                            )

                            if cr_data:

                                scrum_sheet_data[team['team_name']][phase['phase']].add(cr_data['CR_ID'])  # Add CR_ID to set to ensure uniqueness

                # Convert set to list immediately after processing each phase

                scrum_sheet_data[team['team_name']][phase['phase']] = list(scrum_sheet_data[team['team_name']][phase['phase']])

    # print('scrum_sheet_data Created:', scrum_sheet_data)

    return scrum_sheet_data

def calculate_subsystem_percentages_data(selected_sp, selected_team, selected_phase, coverage_summary_data):

    cr_verification_data = create_cr_verification_data_dict(selected_sp)

    scrum_sheet_data = create_scrum_sheet_data(cr_verification_data, coverage_summary_data)

    retest_status_filter_list_for_scrum_sheet = ['Built', 'Withdrawn', 'CannotDuplicate', 'Postponed', 'NotApplicable', 'Ready']

    

    # Find the specific SP data

    sp_data = None

    for sp in coverage_summary_data:

        if sp['sp_name'] == selected_sp:

            sp_data = sp

            break

    if not sp_data:

        return []

    # Find the specific team data

    team_data = None

    for team in sp_data['teams']:

        if team['team_name'] == selected_team:

            team_data = team

            break

    if not team_data:

        return []

    # Filter phases that match the current phase and have coverage types

    matching_phases_data = []

    for phase in team_data['phases']:

        if phase['phase'] == selected_phase:

            matching_phases_data.append(phase)

    if not matching_phases_data:

        return []

    phase_data = matching_phases_data[0]

    total_tcs = phase_data['metrics']['failed'] + phase_data['metrics']['blocked']

    # Filter the data based on the retest status filter list

    filtered_data = []

    for cr_id in scrum_sheet_data.get(selected_team, {}).get(selected_phase, []):

        cr_data = next(

            (item for item in cr_verification_data.get(selected_team, {}).get(selected_phase, [])

             if item['CR_ID'] == cr_id),

            None

        )

        if cr_data and (cr_data['Status'] not in retest_status_filter_list_for_scrum_sheet or cr_data['Status'] is None):

            filtered_data.append(cr_data)

    # Count occurrences of each subsystem

    subsystem_counts = {}

    for entry in filtered_data:

        subsystem = entry['Subsystem']

        if subsystem in subsystem_counts:

            subsystem_counts[subsystem] += 1

        else:

            subsystem_counts[subsystem] = 1

    # Calculate subsystem percentages

    subsystem_percentages = []

    if total_tcs > 0:

        for subsystem in subsystem_counts:

            subsystem_percentage = (subsystem_counts[subsystem] / total_tcs) * 100

            subsystem_percentages.append({

                'subsystem': subsystem,

                'subsystemPercentage': subsystem_percentage

            })

    

    subsystem_percentages.sort(key=lambda x: x['subsystemPercentage'], reverse=True)

    return subsystem_percentages

def add_general_table_to_slide(slide, data, left, top, width, height):

    rows = len(data)

    cols = len(data[0])

    table_shape = slide.shapes.add_table(rows, cols, left, top, width, height)

    table = table_shape.table

    # Define proportional column widths

    column_widths = [Inches(2.0)] * cols  # Adjust column widths as needed

    # Set column widths

    for i, col_width in enumerate(column_widths):

        table.columns[i].width = col_width

    # Set row heights

    for row in table.rows:

        row.height = Inches(0.4)  # Adjust row height as needed

    # Fill the table

    for i, row_data in enumerate(data):

        for j, cell_data in enumerate(row_data):

            cell = table.cell(i, j)

            if cell.text == "":

                cell.text = str(cell_data)

            para = cell.text_frame.paragraphs[0]

            para.font.size = Pt(10)

            para.font.color.rgb = RGBColor(0, 0, 0)

    return table

def add_picture_to_slide(slide, image_path, left, top, width, height):

    """

    Adds a picture to a slide at the specified position and size.

    

    :param slide: The slide to which the picture will be added.

    :param image_path: The path to the image file.

    :param left: The left position of the picture.

    :param top: The top position of the picture.

    :param width: The width of the picture.

    :param height: The height of the picture.

    """

    slide.shapes.add_picture(image_path, left, top, width, height)

def format_percentage(value):

    if value is not None:

        return f"{value:.2f}%"

    else:

        return '0.00%'

def add_test_group_percentages_slides(prs, coverage_summary_data, selected_sp, selected_teams, selected_phases):

    for team_name in selected_teams:

        for phase_name in selected_phases:

            test_group_percentages = calculate_test_group_percentages_data(selected_sp, team_name, phase_name, coverage_summary_data)

            if test_group_percentages:

                test_group_table_data = [['Test Group', 'Test Group Percentage']] + [[tg['test_group'], format_percentage(tg['test_group_percentage'])] for tg in test_group_percentages]

                test_group_title_text = f"{selected_sp} {team_name} {phase_name} Test Group Percentages"

                test_group_slide_layout = prs.slide_layouts[5]  # Title and Content slide

                test_group_slide = prs.slides.add_slide(test_group_slide_layout)

                test_group_title = test_group_slide.shapes.title

                test_group_title.text = test_group_title_text

                add_general_table_to_slide(test_group_slide, test_group_table_data, Inches(3.0), Inches(2), Inches(11.6), Inches(0.4 * len(test_group_table_data)))

def add_subsystem_percentages_slides(prs, coverage_summary_data, selected_sp, selected_teams, selected_phases):

    for team_name in selected_teams:

        for phase_name in selected_phases:

            subsystem_percentages = calculate_subsystem_percentages_data(selected_sp, team_name, phase_name, coverage_summary_data)

            if subsystem_percentages:

                test_group_table_data = [['Subsystem', 'Subsystem Percentage']] + [[tg['subsystem'], format_percentage(tg['subsystemPercentage'])] for tg in subsystem_percentages]

                test_group_title_text = f"{selected_sp} {team_name} {phase_name} Subsystem Percentages"

                test_group_slide_layout = prs.slide_layouts[5]  # Title and Content slide

                test_group_slide = prs.slides.add_slide(test_group_slide_layout)

                test_group_title = test_group_slide.shapes.title

                test_group_title.text = test_group_title_text

                add_general_table_to_slide(test_group_slide, test_group_table_data, Inches(3.0), Inches(2), Inches(11.6), Inches(0.4 * len(test_group_table_data)))

def add_projection_graph_slides(prs, selected_sp, selected_teams, selected_phases):

    projection_graphs_json_path = os.path.join(ConfigPaths.global_scripts_dir, "projected_percentages_csvs_mapping.json")

    image_dir = os.path.join(ConfigPaths.ref_dir, "projection_sheets_pivot_graphs")

    

    with open(projection_graphs_json_path, 'r') as file:

        projection_data = json.load(file)

    

    for team_name in selected_teams:

        for phase_name in selected_phases:

            team_data = projection_data[selected_sp][team_name]

            csv_path = team_data[phase_name]['projection_table']

            if csv_path != "":

                image_path = os.path.join(image_dir, os.path.splitext(csv_path)[0] + '.jpg')

                

                # Create a new slide

                slide_layout = prs.slide_layouts[5]  # Title and Content slide

                slide = prs.slides.add_slide(slide_layout)

                

                # Set the title of the slide

                title = slide.shapes.title

                title.text = f"{selected_sp} {team_name} {phase_name} Projection Graph"

                

                # Add the picture to the slide

                add_picture_to_slide(slide, image_path, Inches(0.5), Inches(2.0), Inches(9.0), Inches(5.0))

# Function to generate the Report

def generate_report(coverage_summary_data, selected_sp, selected_teams=None, selected_phases=None, page_config='team_phase', output_path='report.pptx'):

    prs = Presentation()

    # Add coverage report slides

    add_coverage_report_slides(prs, coverage_summary_data, selected_sp, selected_teams, selected_phases)

    

    # Add test group percentages slides

    add_test_group_percentages_slides(prs, coverage_summary_data, selected_sp, selected_teams, selected_phases)

    

    # Add test group percentages slides

    add_subsystem_percentages_slides(prs, coverage_summary_data, selected_sp, selected_teams, selected_phases)

    

    # Add projection graph slides

    add_projection_graph_slides(prs, selected_sp, selected_teams, selected_phases)

    

    prs.save(output_path)

# Define the path for the scheduler logs

sp_generate_report_path = os.path.join(ConfigPaths.root_dir, "scheduler_logs")

sp_generate_report_error_logs_path = os.path.join(ConfigPaths.root_dir, "scheduler_logs", "sp_generate_report_error_logs") 

sp_reports_data_folder = ConfigPaths.sp_reports_ppts_dir

# Ensure the scheduler_logs, sp_generate_report_error_logs_path directory exists

os.makedirs(sp_generate_report_path, exist_ok=True)

os.makedirs(sp_generate_report_error_logs_path, exist_ok=True)

os.makedirs(sp_reports_data_folder, exist_ok=True)

# Get the current datetime

start_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# Define the log file path for successful executions

log_file_path = os.path.join(sp_generate_report_path, "sp_generate_report_log.txt")

try:

    # Log the start of execution

    with open(log_file_path, "a") as log_file:

        log_file.write(f"\nExecution started at {start_datetime}\n")

    

    active_sps = get_filtered_active_sps()

    # active_sps = ["Bonito.LA.1.0"]

    for sp in active_sps:

        phases_master = ['ES', 'FC', 'CS']

        teams_list = ["BT", "WLAN"]

        phase_dates_df = get_phase_dates_csv()

        selected_team = "All"

        selected_phase = "All"

        all_tc_df = pd.DataFrame()

        all_tc_df = get_sp_df(sp, phase_dates_df, selected_team, selected_phase, all_tc_df)

        phases = list(phases_master)

        table_data = prepare_table_data_active_sps(all_tc_df, phases, phase_dates_df, view_type=ViewType.COVERAGE_REPORT)

        

        for team in teams_list:

            for phase in phases:

                output_path = os.path.join(ConfigPaths.sp_reports_ppts_dir, f'{sp}_{team}_{phase}_report.pptx')

                generate_report(coverage_summary_data=table_data, selected_sp=sp, selected_teams=[team], selected_phases=[phase], page_config='team_phase', output_path=output_path)

    

    end_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Log the successful completion

    with open(log_file_path, "a") as log_file:

        log_file.write(f"Execution successful. Ended at {end_datetime}\n")

    

    # Exit with a success code

    sys.exit(0)

    

except Exception as e:

    end_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Log the failure

    with open(log_file_path, "a") as log_file:

        log_file.write(f"Execution failed. Ended at {end_datetime}\n")

    # Create a new log file with a timestamp for the error

    error_log_file_name = f"error_log_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt"

    error_log_file_path = os.path.join(sp_generate_report_error_logs_path, error_log_file_name)

    with open(error_log_file_path, "w") as error_log_file:

        error_log_file.write(f"Execution started at {end_datetime}\n")

        error_log_file.write(f"Execution failed. Ended at {end_datetime}\n")

        error_log_file.write(f"Error details: {str(e)}\n")

    

    # Exit with a failure code

    sys.exit(1)







this is existing code. As of now, here we are adding each table to a slide, but what i want is i want to add the add_coverage_report_slides slightly up compared to how it is coming now and below of it, on the left i want test_group_percentages_slide and beside it, that is below of coverage report slide and to right of  test_group_percentages_slide beside it i want to have subsystem_percentages_slide. And i want them to use a constant space so that even if the test group percentages or subsystem percentages tables have more rows, still all rows are visible but may be shrinked in size due to assigned space.
