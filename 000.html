// Function to calculate cumulative metrics for each SP and phase
function calculateCumulativeMetrics(data, selectedTeam) {
    return data
        .filter(sp => sp.teams.some(team => team.team_name === selectedTeam))
        .map(sp => {
            const teamData = sp.teams.find(team => team.team_name === selectedTeam);
            if (!teamData) return null;

            const processedPhases = teamData.phases.map(phase => {
                let totalTCs = 0;
                let totalCoverage = 0;
                let totalPassed = 0;
                let totalFailed = 0;
                let totalBlocked = 0;

                if (phase.coverage_types) {
                    phase.coverage_types.forEach(ct => {
                        totalTCs += parseInt(ct.metrics.total || 0);
                        totalCoverage += parseInt(ct.metrics.coverage || 0);
                        totalPassed += parseInt(ct.metrics.passed || 0);
                        totalFailed += parseInt(ct.metrics.failed || 0);
                        totalBlocked += parseInt(ct.metrics.blocked || 0);
                    });
                } else {
                    totalTCs = parseInt(phase.metrics.total || 0);
                    totalCoverage = parseInt(phase.metrics.coverage || 0);
                    totalPassed = parseInt(phase.metrics.passed || 0);
                    totalFailed = parseInt(phase.metrics.failed || 0);
                    totalBlocked = parseInt(phase.metrics.blocked || 0);
                }

                const coveragePercentage = totalTCs > 0 ? (totalCoverage / totalTCs) * 100 : 0;
                const passPercentage = totalTCs > 0 ? (totalPassed / totalTCs) * 100 : 0;
                const failPercentage = totalTCs > 0 ? (totalFailed / totalTCs) * 100 : 0;
                const blockPercentage = totalTCs > 0 ? (totalBlocked / totalTCs) * 100 : 0;

                return {
                    phase: phase.phase,
                    metrics: {
                        total: totalTCs,
                        coverage: totalCoverage,
                        coverage_percentage: coveragePercentage,
                        passed: totalPassed,
                        passed_percentage: passPercentage,
                        failed: totalFailed,
                        failed_percentage: failPercentage,
                        blocked: totalBlocked,
                        blocked_percentage: blockPercentage
                    }
                };
            });

            return {
                phases: processedPhases
            };
        })
        .filter(Boolean);
}

// Function to render the cumulative metrics table
function renderCumulativeTable(data, targetElementId) {
    const table = document.createElement('table');
    table.className = 'coverage-table';

    // Create header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const headers = [
        'Phase', 
        'Total TCs',
        'Coverage', 'Coverage %',
        'Passed', 'Pass %',
        'Failed', 'Fail %',
        'Blocked', 'Block %'
    ];
    headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Create table body
    const tbody = document.createElement('tbody');
    data.forEach(sp => {
        sp.phases.forEach(phase => {
            const tr = document.createElement('tr');
            const cells = [
                phase.phase,
                phase.metrics.total,
                phase.metrics.coverage,
                formatPercentage(phase.metrics.coverage_percentage),
                phase.metrics.passed,
                formatPercentage(phase.metrics.passed_percentage),
                phase.metrics.failed,
                formatPercentage(phase.metrics.failed_percentage),
                phase.metrics.blocked,
                formatPercentage(phase.metrics.blocked_percentage)
            ];
            cells.forEach(cellData => {
                const td = document.createElement('td');
                td.textContent = cellData;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
    });
    table.appendChild(tbody);

    // Render the table
    const targetElement = document.getElementById(targetElementId);
    targetElement.innerHTML = '';
    targetElement.appendChild(table);
}