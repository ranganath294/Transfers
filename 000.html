import pandas as pd
import logging
from cst_reporting_views.scripts.legacy_new_fr_view import calculate_counts


def prepare_table_data_active_sps(
    all_tc_df, phases, phase_dates_df, include_values=False, coverage_types=None, include_coverage_types=False
):
    if coverage_types is None:
        coverage_types = ['Legacy', 'NewFR']

    # Main preparation function
    phase_data = get_phase_data(all_tc_df, phases, coverage_types, include_coverage_types)

    table_data = []
    for sp_name, sp_group in all_tc_df.groupby('SP Name'):
        sp_teams = process_sp_teams(sp_name, sp_group, phases, phase_data, phase_dates_df, include_values, include_coverage_types, coverage_types)
        table_data.append({'sp_name': sp_name, 'teams': sp_teams})

    return table_data


def get_phase_data(all_tc_df, phases, coverage_types, include_coverage_types):
    if include_coverage_types:
        return {
            phase: {coverage_type: calculate_phase_metrics(all_tc_df, phase, coverage_type)
                    for coverage_type in coverage_types}
            for phase in phases
        }
    return {phase: calculate_phase_metrics(all_tc_df, phase) for phase in phases}


def calculate_phase_metrics(df, phase, coverage_type=None):
    filtered_df = df[(df['Test Phase'] == phase)]
    if coverage_type:
        filtered_df = filtered_df[filtered_df['Legacy_NewFRs'] == coverage_type]

    metrics = filtered_df.groupby(['SP Name', 'Test Team']).agg(
        total=('Result', 'size'),
        passed=('Result', lambda x: (x == 'Passed').sum()),
        failed=('Result', lambda x: (x == 'Failed').sum()),
        blocked=('Result', lambda x: (x == 'Blocked').sum())
    ).reset_index()

    metrics['coverage'] = metrics['passed'] + metrics['failed']
    metrics.update({
        f"{col}_percentage": (metrics[col] / metrics['total'] * 100).fillna(0)
        for col in ['coverage', 'passed', 'failed', 'blocked']
    })
    return metrics


def process_sp_teams(sp_name, sp_group, phases, phase_data, phase_dates_df, include_values, include_coverage_types, coverage_types):
    sp_teams = []
    for team_name, team_group in sp_group.groupby('Test Team'):
        team_phase_data = process_team_phases(sp_name, team_name, team_group, phases, phase_data, phase_dates_df, include_values, include_coverage_types, coverage_types)
        sp_teams.append({'team_name': team_name, 'phases': team_phase_data})
    return sp_teams


def process_team_phases(sp_name, team_name, team_group, phases, phase_data, phase_dates_df, include_values, include_coverage_types, coverage_types):
    team_phase_data = []
    for phase in phases:
        phase_info = process_phase_info(sp_name, team_name, phase, phase_data, phase_dates_df, include_values, include_coverage_types, coverage_types)
        team_phase_data.append(phase_info)
    return team_phase_data


def process_phase_info(sp_name, team_name, phase, phase_data, phase_dates_df, include_values, include_coverage_types, coverage_types):
    phase_date = get_phase_date(sp_name, phase, phase_dates_df)

    if include_coverage_types:
        coverage_data = [
            process_coverage_type(sp_name, team_name, phase, phase_data[phase][coverage_type], coverage_type, include_values)
            for coverage_type in coverage_types
        ]
        return {'phase': phase, 'date': phase_date, 'coverage_types': coverage_data}

    metrics = get_metrics(sp_name, team_name, phase_data[phase])
    unique_cr_count = calculate_unique_cr_count(sp_name, team_name, phase, None)
    return {
        'phase': phase,
        'date': phase_date,
        'metrics': format_metrics(metrics, include_values),
        'unique_cr_count': unique_cr_count
    }


def process_coverage_type(sp_name, team_name, phase, phase_metrics, coverage_type, include_values):
    metrics = get_metrics(sp_name, team_name, phase_metrics)
    unique_cr_count = calculate_unique_cr_count(sp_name, team_name, phase, coverage_type)
    return {
        'coverage_type': coverage_type,
        'metrics': format_metrics(metrics, include_values),
        'unique_cr_count': unique_cr_count
    }


def get_phase_date(sp_name, phase, phase_dates_df):
    if phase in ["ES", "FC", "CS"]:
        date_value = phase_dates_df.loc[phase_dates_df['FirstCustomerSP'] == sp_name, phase]
        if not date_value.empty and pd.notna(date_value.iloc[0]):
            return date_value.iloc[0].strftime('%m-%d-%Y')
    return "NA"


def get_metrics(sp_name, team_name, phase_metrics):
    metrics = phase_metrics[
        (phase_metrics['SP Name'] == sp_name) & (phase_metrics['Test Team'] == team_name)
    ].to_dict('records')
    return metrics[0] if metrics else {
        'total': 0,
        'passed': 0,
        'failed': 0,
        'blocked': 0,
        'coverage': 0,
        'coverage_percentage': 0,
        'passed_percentage': 0,
        'failed_percentage': 0,
        'blocked_percentage': 0
    }


def calculate_unique_cr_count(sp_name, team_name, phase, coverage_type):
    # Replace `filter_func` inline logic for flexibility
    filter_func = lambda df: (
        (df['SP Name'] == sp_name) &
        (df['Test Team'] == team_name) &
        (df['Test Phase'] == phase) &
        ((df['Legacy_NewFRs'] == coverage_type) if coverage_type else True)
    )
    if 'All_Issues' in all_tc_df.columns:
        unique_cr_counts, column_name_result = calculate_counts(all_tc_df, 'All_Issues', filter_func=filter_func, unique=True)
        return unique_cr_counts.set_index('Test Team').loc[team_name, column_name_result] if not unique_cr_counts.empty else 0
    logging.warning(f"Column 'All_Issues' not found for SP Name: {sp_name}, Test Team: {team_name}, Phase: {phase}, Coverage Type: {coverage_type}")
    return 0


def format_metrics(metrics, include_values):
    formatted_metrics = {
        'coverage_percentage': metrics['coverage_percentage'],
        'passed_percentage': metrics['passed_percentage'],
        'failed_percentage': metrics['failed_percentage'],
        'blocked_percentage': metrics['blocked_percentage']
    }
    if include_values:
        formatted_metrics.update({
            'total': metrics['total'],
            'passed': metrics['passed'],
            'failed': metrics['failed'],
            'blocked': metrics['blocked'],
            'coverage': metrics['coverage']
        })
    return formatted_metrics
