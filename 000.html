{% extends 'base.html' %}
{% block content %}
<div class="container container-fluid">
    <h1 class="page-title">Coverage Report</h1>
    <div class="card mb-3">
        <div class="card-body">
            <div class="row mb-3">
                <div class="col-md-6">
                    <div class="form-group">
                        <label for="sp_name" class="form-label">Select SP:</label>
                        <div class="input-group">
                            <select id="sp_name" name="sp_name" class="form-select">
                                <option value="">--No SP Selected--</option>
                                {% for sp_name in sp_names %}
                                    <option value="{{ sp_name }}" {% if sp_name == selected_sp %}selected{% endif %}>{{ sp_name }}</option>
                                {% endfor %}
                            </select>
                            <button id="getDataBtn" class="btn btn-primary">Get Data</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="teamFilters" style="display: none;" class="mb-3">
                <div class="btn-group" role="group" aria-label="Test Team filters">
                    <input type="radio" class="btn-check team-filter" name="team-filter" id="all" value="all" checked>
                    <label class="btn btn-outline-primary" for="all">All Teams</label>
                    <input type="radio" class="btn-check team-filter" name="team-filter" id="bt" value="BT">
                    <label class="btn btn-outline-primary" for="bt">BT</label>
                    <input type="radio" class="btn-check team-filter" name="team-filter" id="wlan" value="WLAN">
                    <label class="btn btn-outline-primary" for="wlan">WLAN</label>
                </div>
            </div>
            <div id="tableContainer" class="table-responsive">
                <!-- Table will be rendered here -->
            </div>
        </div>
    </div>
</div>
<style>
.container {
    padding: 2rem;
    max-width: 1500px;
}
.btn-group {
    margin-right: 10px;
}
.btn-group .btn {
    margin-right: 2px;
}
.coverage-table {
    border-collapse: collapse;
    width: 100%;
    margin: 20px 0;
    table-layout: auto;  /* Allow columns to size based on content */
    border: 1px solid black; /* Solid black border for the table */
}
.coverage-table th,
.coverage-table td {
    border: 1px solid black; /* Solid black borders for table cells */
    padding: 8px;
    text-align: left;
    font-size: 15px; /* Set font size to 15px */
    color: black; /* Set text color to black */
    white-space: nowrap;  /* Prevent wrapping in data cells */
}
.coverage-table th {
    background-color: #328AA4; /* Set background color for headers */
    font-weight: bold;
    color: white; /* Set text color for headers to white */
    position: relative;
    white-space: normal;  /* Allow header text to wrap */
    word-wrap: break-word;  /* Break long words if necessary */
    min-width: 50px;  /* Minimum width for columns */
    max-width: 150px;  /* Maximum width for headers */
    overflow: hidden;
    text-overflow: ellipsis;  /* Show ellipsis for overflowing header text */
}
.coverage-table tbody tr:nth-child(even) {
    background-color: #f9f9f9;
}
/* Add horizontal scrolling for the table container if needed */
.table-responsive {
    overflow-x: auto;
    max-width: 100%;
}
</style>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const getDataBtn = document.getElementById('getDataBtn');
        const teamFilters = document.querySelectorAll('.team-filter');
        const teamFiltersContainer = document.getElementById('teamFilters');
        let selectedTeams = ['all'];
        let tableData = null;

        function adjustColumnWidths() {
            const table = document.querySelector('.coverage-table');
            if (!table) return;
        
            // Reset any previously set widths
            const cells = table.querySelectorAll('th, td');
            cells.forEach(cell => cell.style.width = '');
        
            // Let the browser render the table first
            setTimeout(() => {
                const headerCells = table.querySelectorAll('th');
                const bodyCells = Array.from(table.querySelectorAll('tbody tr:first-child td'));
        
                // Calculate maximum width needed for data cells in each column
                bodyCells.forEach((cell, index) => {
                    const columnCells = Array.from(table.querySelectorAll(`tbody td:nth-child(${index + 1})`));
                    const maxWidth = Math.max(...columnCells.map(cell => cell.offsetWidth));
                    
                    // Set width based on data content
                    columnCells.forEach(cell => cell.style.width = `${maxWidth}px`);
                    if (headerCells[index]) {
                        headerCells[index].style.width = `${maxWidth}px`;
                    }
                });
            }, 0);
        }
    
        // Handle team filter changes
        teamFilters.forEach(filter => {
            filter.addEventListener('change', (e) => {
                const selectedValue = e.target.value;
                if (selectedValue === 'all') {
                    selectedTeams = ['all'];
                    if (tableData) {
                        renderCoverageTable(filterData(tableData, selectedTeams), 'tableContainer');
                    }
                } else {
                    selectedTeams = [selectedValue];
                    if (tableData) {
                        const cumulativeData = calculateCumulativeMetrics(tableData, selectedValue);
                        renderCumulativeTable(cumulativeData, 'tableContainer');
                    }
                }
            });
        });
    
        function setLoadingState(isLoading) {
            getDataBtn.disabled = isLoading;
            getDataBtn.innerHTML = isLoading ? 'Loading...' : 'Get Data';
        }
    
        // Handle Get Data button click
        getDataBtn.addEventListener('click', async function() {
            const spSelect = document.getElementById('sp_name');
            const selectedSp = spSelect.value;
            if (!selectedSp) {
                alert('Please select an SP first');
                return;
            }
            setLoadingState(true);
            const params = new URLSearchParams();
            params.append('sp_name', selectedSp);
            if (selectedTeams.includes('all')) {
                params.append('teams', 'all');
            } else {
                selectedTeams.forEach(team => params.append('teams', team));
            }
            try {
                const response = await fetch(`{% url 'cst_reporting_views:coverage_report' %}?${params.toString()}`);
                if (!response.ok) throw new Error('Network response was not ok');
                const responseData = await response.json();
                tableData = responseData["table_data"];
                console.log(tableData);
                teamFiltersContainer.style.display = 'block';
                renderCoverageTable(tableData, 'tableContainer');
            } catch (error) {
                console.error('Error fetching data:', error);
                alert('Error fetching data. Please try again.');
            } finally {
                setLoadingState(false);
            }
        });
    
        // Helper function to filter data based on selected teams
        function filterData(data, selectedTeams) {
            if (selectedTeams.includes('all')) {
                return data;
            }
            return data.map(sp => ({
                ...sp,
                teams: sp.teams.filter(team => selectedTeams.includes(team.team_name))
            })).filter(sp => sp.teams.length > 0);
        }
    
        // Helper functions
        function calculateSpRowspan(sp) {
            return sp.teams.reduce((acc, team) => {
                return acc + calculateTeamRowspan(team);
            }, 0);
        }
    
        function calculateTeamRowspan(team) {
            return team.phases.reduce((acc, phase) => {
                if (phase.coverage_types) {
                    return acc + phase.coverage_types.length;
                }
                return acc + 1;
            }, 0);
        }
    
        function formatPercentage(value) {
            return value ? value.toFixed(2) + '%' : '0.00%';
        }
    
        // Function to render the coverage table
        function renderCoverageTable(data, targetElementId) {
            const table = document.createElement('table');
            table.className = 'coverage-table';
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = [
                'SP Name', 'Test Team', 'Date', 'Phase', 'Coverage Type',
                'Total TCs', 'Coverage', 'Coverage %', 'Passed', 'Pass %',
                'Failed', 'Fail %', 'Blocked', 'Block %', 'Unique Issues Issued'
            ];
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            // Create table body
            const tbody = document.createElement('tbody');
            data.forEach(sp => {
                const spRowspan = calculateSpRowspan(sp);
                let isFirstSpRow = true;
                sp.teams.forEach(team => {
                    const teamRowspan = calculateTeamRowspan(team);
                    let isFirstTeamRow = true;
                    team.phases.forEach(phase => {
                        if (phase.coverage_types) {
                            // Handle multiple coverage types
                            phase.coverage_types.forEach((coverageType, ctIndex) => {
                                const tr = document.createElement('tr');
                                // SP Name column
                                if (isFirstSpRow) {
                                    const tdSp = document.createElement('td');
                                    tdSp.textContent = sp.sp_name;
                                    tdSp.rowSpan = spRowspan;
                                    tr.appendChild(tdSp);
                                    isFirstSpRow = false;
                                }
                                // Team Name column
                                if (isFirstTeamRow) {
                                    const tdTeam = document.createElement('td');
                                    tdTeam.textContent = team.team_name;
                                    tdTeam.rowSpan = teamRowspan;
                                    tr.appendChild(tdTeam);
                                    isFirstTeamRow = false;
                                }
                                // Phase date
                                if (ctIndex === 0) {
                                    const tdDate = document.createElement('td');
                                    tdDate.textContent = phase.date;
                                    tdDate.rowSpan = phase.coverage_types.length;
                                    tr.appendChild(tdDate);
                                    const tdPhase = document.createElement('td');
                                    tdPhase.textContent = phase.phase;
                                    tdPhase.rowSpan = phase.coverage_types.length;
                                    tr.appendChild(tdPhase);
                                }
                                // Coverage type and metrics
                                const cells = [
                                    coverageType.coverage_type,
                                    coverageType.metrics.total || '0',
                                    coverageType.metrics.coverage || '0',
                                    formatPercentage(coverageType.metrics.coverage_percentage),
                                    coverageType.metrics.passed || '0',
                                    formatPercentage(coverageType.metrics.passed_percentage),
                                    coverageType.metrics.failed || '0',
                                    formatPercentage(coverageType.metrics.failed_percentage),
                                    coverageType.metrics.blocked || '0',
                                    formatPercentage(coverageType.metrics.blocked_percentage),
                                    coverageType.unique_issue_count
                                ];
                                cells.forEach(cellData => {
                                    const td = document.createElement('td');
                                    td.textContent = cellData;
                                    tr.appendChild(td);
                                });
                                tbody.appendChild(tr);
                            });
                        } else {
                            // Handle single coverage type
                            const tr = document.createElement('tr');
                            if (isFirstSpRow) {
                                const tdSp = document.createElement('td');
                                tdSp.textContent = sp.sp_name;
                                tdSp.rowSpan = spRowspan;
                                tr.appendChild(tdSp);
                                isFirstSpRow = false;
                            }
                            if (isFirstTeamRow) {
                                const tdTeam = document.createElement('td');
                                tdTeam.textContent = team.team_name;
                                tdTeam.rowSpan = teamRowspan;
                                tr.appendChild(tdTeam);
                                isFirstTeamRow = false;
                            }
                            const cells = [
                                phase.date,
                                phase.phase,
                                'All',
                                phase.metrics.total || '0',
                                phase.metrics.coverage || '0',
                                formatPercentage(phase.metrics.coverage_percentage),
                                phase.metrics.passed || '0',
                                formatPercentage(phase.metrics.passed_percentage),
                                phase.metrics.failed || '0',
                                formatPercentage(phase.metrics.failed_percentage),
                                phase.metrics.blocked || '0',
                                formatPercentage(phase.metrics.blocked_percentage),
                                phase.unique_issue_count
                            ];
                            cells.forEach(cellData => {
                                const td = document.createElement('td');
                                td.textContent = cellData;
                                tr.appendChild(td);
                            });
                            tbody.appendChild(tr);
                        }
                    });
                });
            });
            table.appendChild(tbody);
            // Add basic styles
            const style = document.createElement('style');
            style.textContent = `
            .coverage-table {
                border-collapse: collapse;
                width: 100%;
                margin: 20px 0;
            }
            .coverage-table th, .coverage-table td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            .coverage-table th {
                background-color: #f5f5f5;
                font-weight: bold;
            }
            .coverage-table tbody tr:nth-child(even) {
                background-color: #f9f9f9;
            }
            `;
            document.head.appendChild(style);
            // Render the table
            const targetElement = document.getElementById(targetElementId);
            targetElement.innerHTML = '';
            targetElement.appendChild(table);

            // Adjust column widths
            adjustColumnWidths();
        }

        // Function to calculate cumulative metrics for each SP and phase
        function calculateCumulativeMetrics(data, selectedTeam) {
            return data
                .filter(sp => sp.teams.some(team => team.team_name === selectedTeam))
                .map(sp => {
                    const teamData = sp.teams.find(team => team.team_name === selectedTeam);
                    if (!teamData) return null;

                    const processedPhases = teamData.phases.map(phase => {
                        let totalTCs = 0;
                        let totalCoverage = 0;
                        let totalPassed = 0;
                        let totalFailed = 0;
                        let totalBlocked = 0;

                        if (phase.coverage_types) {
                            phase.coverage_types.forEach(ct => {
                                totalTCs += parseInt(ct.metrics.total || 0);
                                totalCoverage += parseInt(ct.metrics.coverage || 0);
                                totalPassed += parseInt(ct.metrics.passed || 0);
                                totalFailed += parseInt(ct.metrics.failed || 0);
                                totalBlocked += parseInt(ct.metrics.blocked || 0);
                            });
                        } else {
                            totalTCs = parseInt(phase.metrics.total || 0);
                            totalCoverage = parseInt(phase.metrics.coverage || 0);
                            totalPassed = parseInt(phase.metrics.passed || 0);
                            totalFailed = parseInt(phase.metrics.failed || 0);
                            totalBlocked = parseInt(phase.metrics.blocked || 0);
                        }

                        const coveragePercentage = totalTCs > 0 ? (totalCoverage / totalTCs) * 100 : 0;
                        const passPercentage = totalTCs > 0 ? (totalPassed / totalTCs) * 100 : 0;
                        const failPercentage = totalTCs > 0 ? (totalFailed / totalTCs) * 100 : 0;
                        const blockPercentage = totalTCs > 0 ? (totalBlocked / totalTCs) * 100 : 0;

                        return {
                            phase: phase.phase,
                            metrics: {
                                total: totalTCs,
                                coverage: totalCoverage,
                                coverage_percentage: coveragePercentage,
                                passed: totalPassed,
                                passed_percentage: passPercentage,
                                failed: totalFailed,
                                failed_percentage: failPercentage,
                                blocked: totalBlocked,
                                blocked_percentage: blockPercentage
                            }
                        };
                    });

                    return {
                        phases: processedPhases
                    };
                })
                .filter(Boolean);
        }

        // Function to render the cumulative metrics table
        function renderCumulativeTable(data, targetElementId) {
            const table = document.createElement('table');
            table.className = 'coverage-table';

            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = [
                'Phase', 
                'Total TCs',
                'Coverage', 'Coverage %',
                'Passed', 'Pass %',
                'Failed', 'Fail %',
                'Blocked', 'Block %'
            ];
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');
            data.forEach(sp => {
                sp.phases.forEach(phase => {
                    const tr = document.createElement('tr');
                    const cells = [
                        phase.phase,
                        phase.metrics.total,
                        phase.metrics.coverage,
                        formatPercentage(phase.metrics.coverage_percentage),
                        phase.metrics.passed,
                        formatPercentage(phase.metrics.passed_percentage),
                        phase.metrics.failed,
                        formatPercentage(phase.metrics.failed_percentage),
                        phase.metrics.blocked,
                        formatPercentage(phase.metrics.blocked_percentage)
                    ];
                    cells.forEach(cellData => {
                        const td = document.createElement('td');
                        td.textContent = cellData;
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
            });
            table.appendChild(tbody);

            // Render the table
            const targetElement = document.getElementById(targetElementId);
            targetElement.innerHTML = '';
            targetElement.appendChild(table);

            // Adjust column widths
            adjustColumnWidths();
        }
    });
    
</script>
{% endblock %}


import pandas as pd
import logging
from cst_reporting_views.scripts.legacy_new_fr_view import calculate_counts

def prepare_table_data_active_sps(all_tc_df, phases, phase_dates_df, include_values=False, coverage_types=None, include_coverage_types=False):
    if coverage_types is None:
        coverage_types = ['Legacy', 'NewFR']
    phase_data = calculate_phase_data(all_tc_df, phases, coverage_types, include_coverage_types)
    table_data = build_table_data(all_tc_df, phase_data, phases, phase_dates_df, include_values, coverage_types, include_coverage_types)
    return table_data

def calculate_phase_data(all_tc_df, phases, coverage_types, include_coverage_types):
    if include_coverage_types:
        return {
            phase: {coverage_type: calculate_phase_metrics(all_tc_df, phase, coverage_type) for coverage_type in coverage_types}
            for phase in phases
        }
    else:
        return {phase: calculate_phase_metrics(all_tc_df, phase) for phase in phases}

def calculate_phase_metrics(df, phase, coverage_type=None):
    if coverage_type is not None:
        filtered_df = df[
            (df['Test Phase'] == phase) &
            (df['Legacy_NewFRs'] == coverage_type)
        ]
    else:
        filtered_df = df[df['Test Phase'] == phase]
    metrics = filtered_df.groupby(['SP Name', 'Test Team']).agg(
        total=('Result', 'size'),
        passed=('Result', lambda x: (x == 'Passed').sum()),
        failed=('Result', lambda x: (x == 'Failed').sum()),
        blocked=('Result', lambda x: (x == 'Blocked').sum())
    ).reset_index()
    metrics['coverage'] = metrics['passed'] + metrics['failed']
    metrics['coverage_percentage'] = (metrics['coverage'] / metrics['total'] * 100).fillna(0)
    metrics['passed_percentage'] = (metrics['passed'] / metrics['total'] * 100).fillna(0)
    metrics['failed_percentage'] = (metrics['failed'] / metrics['total'] * 100).fillna(0)
    metrics['blocked_percentage'] = (metrics['blocked'] / metrics['total'] * 100).fillna(0)
    return metrics

def build_table_data(all_tc_df, phase_data, phases, phase_dates_df, include_values, coverage_types, include_coverage_types):
    table_data = []
    sp_groups = all_tc_df.groupby('SP Name')
    for sp_name, sp_group in sp_groups:
        sp_teams = []
        team_groups = sp_group.groupby('Test Team')
        for team_name, team_group in team_groups:
            team_phase_data = []
            for phase in phases:
                phase_info = process_phase_data(
                    all_tc_df, phase_data, phase_dates_df, sp_name, team_name, phase,
                    include_coverage_types, coverage_types, include_values
                )
                team_phase_data.append(phase_info)
            sp_teams.append({
                'team_name': team_name,
                'phases': team_phase_data
            })
        table_data.append({
            'sp_name': sp_name,
            'teams': sp_teams
        })
    return table_data

def extract_unique_cr_and_jira(unique_issue_list):
    """
    Extracts unique CR and JIRA issues from the unique_issue_list.
    
    Args:
        unique_issue_list (list): List of unique issue strings.
    
    Returns:
        tuple: A tuple containing unique_cr_list, unique_cr_count, unique_jira_list, and unique_jira_count.
    """
    unique_cr_list = [issue for issue in unique_issue_list if issue.startswith("CR-")]
    unique_cr_count = len(unique_cr_list)
    unique_jira_list = [issue for issue in unique_issue_list if issue.startswith(("QSTABILITY-", "CNSSDEBUG-"))]
    unique_jira_count = len(unique_jira_list)
    return unique_cr_list, unique_cr_count, unique_jira_list, unique_jira_count

def get_unique_issue_counts(all_tc_df, sp_name, team_name, phase, coverage_type=None):
    # Define the base filter function
    base_filter_func = lambda df: ((df['SP Name'] == sp_name) &
                                  (df['Test Team'] == team_name) &
                                  (df['Test Phase'] == phase))
    # If coverage_type is provided, extend the filter function
    if coverage_type:
        filter_func = lambda df: base_filter_func(df) & (df['Legacy_NewFRs'] == coverage_type)
    else:
        filter_func = base_filter_func
    
    if 'All_Issues' in all_tc_df.columns:
        unique_issue_counts, column_name_result, unique_issue_lists = calculate_counts(all_tc_df, 'All_Issues', filter_func=filter_func, unique=True)
        unique_issue_count = unique_issue_counts.set_index('Test Team').loc[team_name, column_name_result] if not unique_issue_counts.empty else 0
        unique_issue_list = unique_issue_lists.get(team_name, [])
        
        # Extract unique CR and JIRA issues
        unique_cr_list, unique_cr_count, unique_jira_list, unique_jira_count = extract_unique_cr_and_jira(unique_issue_list)
        
        return unique_issue_count, unique_issue_list, unique_cr_list, unique_cr_count, unique_jira_list, unique_jira_count
    else:
        logging.warning(f"Column 'All_Issues' not found in DataFrame for SP Name: {sp_name}, Test Team: {team_name}, Phase: {phase}, Coverage Type: {coverage_type}")
        return 0, [], [], 0, [], 0

def process_phase_data(all_tc_df, phase_data, phase_dates_df, sp_name, team_name, phase, include_coverage_types, coverage_types, include_values):
    if include_coverage_types:
        phase_coverage_data = []
        for coverage_type in coverage_types:
            phase_metrics = phase_data[phase][coverage_type]
            metrics = get_metrics(phase_metrics, sp_name, team_name)
            phase_date = get_phase_date(phase_dates_df, sp_name, phase)
            unique_issue_count, unique_issue_list, unique_cr_list, unique_cr_count, unique_jira_list, unique_jira_count = get_unique_issue_counts(all_tc_df, sp_name, team_name, phase, coverage_type)
            phase_coverage_info = {
                'coverage_type': coverage_type,
                'metrics': format_metrics(metrics, include_values),
                'unique_issue_count': int(unique_issue_count),
                'unique_issue_list': unique_issue_list,
                'unique_cr_list': unique_cr_list,
                'unique_cr_count': unique_cr_count,
                'unique_jira_list': unique_jira_list,
                'unique_jira_count': unique_jira_count
            }
            phase_coverage_data.append(phase_coverage_info)
        phase_info = {
            'phase': phase,
            'date': phase_date,
            'coverage_types': phase_coverage_data
        }
    else:
        phase_metrics = phase_data[phase]
        metrics = get_metrics(phase_metrics, sp_name, team_name)
        phase_date = get_phase_date(phase_dates_df, sp_name, phase)
        unique_issue_count, unique_issue_list, unique_cr_list, unique_cr_count, unique_jira_list, unique_jira_count = get_unique_issue_counts(all_tc_df, sp_name, team_name, phase)
        phase_info = {
            'phase': phase,
            'date': phase_date,
            'metrics': format_metrics(metrics, include_values),
            'unique_issue_count': int(unique_issue_count),
            'unique_issue_list': unique_issue_list,
            'unique_cr_list': unique_cr_list,
            'unique_cr_count': unique_cr_count,
            'unique_jira_list': unique_jira_list,
            'unique_jira_count': unique_jira_count
        }
    return phase_info

def get_metrics(phase_metrics, sp_name, team_name):
    metrics = phase_metrics[
        (phase_metrics['SP Name'] == sp_name) &
        (phase_metrics['Test Team'] == team_name)
    ].to_dict('records')
    return metrics[0] if metrics else {
        'total': 0,
        'passed': 0,
        'failed': 0,
        'blocked': 0,
        'coverage': 0,
        'coverage_percentage': 0,
        'passed_percentage': 0,
        'failed_percentage': 0,
        'blocked_percentage': 0
    }

def get_phase_date(phase_dates_df, sp_name, phase):
    phase_date = "NA"
    if phase in ["ES", "FC", "CS"]:
        date_value = phase_dates_df.loc[
            phase_dates_df['FirstCustomerSP'] == sp_name,
            phase
        ].iloc[0] if not phase_dates_df[
            phase_dates_df['FirstCustomerSP'] == sp_name
        ].empty else None
        if pd.notna(date_value):
            phase_date = date_value.strftime('%m-%d-%Y')
    return phase_date

def format_metrics(metrics, include_values):
    formatted_metrics = {
        'coverage_percentage': metrics['coverage_percentage'],
        'passed_percentage': metrics['passed_percentage'],
        'failed_percentage': metrics['failed_percentage'],
        'blocked_percentage': metrics['blocked_percentage']
    }
    if include_values:
        formatted_metrics.update({
            'total': metrics['total'],
            'passed': metrics['passed'],
            'failed': metrics['failed'],
            'blocked': metrics['blocked'],
            'coverage': metrics['coverage']
        })
    return formatted_metrics
