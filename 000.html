// Function to calculate cumulative metrics for each SP and phase
function calculateCumulativeMetrics(data, selectedTeam) {
    // Filter SPs that have the selected team
    return data
        .filter(sp => sp.teams.some(team => team.team_name === selectedTeam))
        .map(sp => {
            // Get only the selected team's data
            const teamData = sp.teams.find(team => team.team_name === selectedTeam);
            if (!teamData) return null;

            // Process each phase
            const processedPhases = teamData.phases.map(phase => {
                let totalTCs = 0;
                let totalCoverage = 0;
                let totalPassed = 0;
                let totalFailed = 0;
                let totalBlocked = 0;

                // If phase has coverage types, process each type
                if (phase.coverage_types) {
                    phase.coverage_types.forEach(ct => {
                        totalTCs += parseInt(ct.metrics.total || 0);
                        totalCoverage += parseInt(ct.metrics.coverage || 0);
                        totalPassed += parseInt(ct.metrics.passed || 0);
                        totalFailed += parseInt(ct.metrics.failed || 0);
                        totalBlocked += parseInt(ct.metrics.blocked || 0);
                    });
                } else {
                    // If phase has direct metrics
                    totalTCs = parseInt(phase.metrics.total || 0);
                    totalCoverage = parseInt(phase.metrics.coverage || 0);
                    totalPassed = parseInt(phase.metrics.passed || 0);
                    totalFailed = parseInt(phase.metrics.failed || 0);
                    totalBlocked = parseInt(phase.metrics.blocked || 0);
                }

                // Calculate percentages
                const coveragePercentage = totalTCs > 0 ? (totalCoverage / totalTCs) * 100 : 0;
                const passPercentage = totalTCs > 0 ? (totalPassed / totalTCs) * 100 : 0;
                const failPercentage = totalTCs > 0 ? (totalFailed / totalTCs) * 100 : 0;
                const blockPercentage = totalTCs > 0 ? (totalBlocked / totalTCs) * 100 : 0;

                return {
                    sp_name: sp.sp_name,
                    date: phase.date,
                    phase: phase.phase,
                    metrics: {
                        total: totalTCs,
                        coverage_percentage: coveragePercentage,
                        passed_percentage: passPercentage,
                        failed_percentage: failPercentage,
                        blocked_percentage: blockPercentage
                    }
                };
            });

            return {
                sp_name: sp.sp_name,
                phases: processedPhases
            };
        })
        .filter(Boolean); // Remove null entries
}

// Function to render the cumulative metrics table
function renderCumulativeTable(data, targetElementId) {
    const table = document.createElement('table');
    table.className = 'coverage-table';

    // Create header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const headers = [
        'SP Name', 'Date', 'Phase', 'Total TCs', 
        'Coverage %', 'Pass %', 'Fail %', 'Block %'
    ];
    headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Create table body
    const tbody = document.createElement('tbody');
    data.forEach(sp => {
        sp.phases.forEach(phase => {
            const tr = document.createElement('tr');
            const cells = [
                sp.sp_name,
                phase.date,
                phase.phase,
                phase.metrics.total,
                formatPercentage(phase.metrics.coverage_percentage),
                formatPercentage(phase.metrics.passed_percentage),
                formatPercentage(phase.metrics.failed_percentage),
                formatPercentage(phase.metrics.blocked_percentage)
            ];
            cells.forEach(cellData => {
                const td = document.createElement('td');
                td.textContent = cellData;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
    });
    table.appendChild(tbody);

    // Render the table
    const targetElement = document.getElementById(targetElementId);
    targetElement.innerHTML = '';
    targetElement.appendChild(table);
}












teamFilters.forEach(filter => {
    filter.addEventListener('change', (e) => {
        const selectedValue = e.target.value;
        if (selectedValue === 'all') {
            selectedTeams = ['all'];
            if (tableData) {
                renderCoverageTable(filterData(tableData, selectedTeams), 'tableContainer');
            }
        } else {
            selectedTeams = [selectedValue];
            if (tableData) {
                const cumulativeData = calculateCumulativeMetrics(tableData, selectedValue);
                renderCumulativeTable(cumulativeData, 'tableContainer');
            }
        }
    });
});