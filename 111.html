class ConfigInputHandler {
    // ... (previous code remains the same until createTypeSelector)

    // Custom type selector to handle nested array types
    createTypeSelector(initialType) {
        const select = document.createElement('select');
        select.className = 'form-select mb-2';

        // Handle array types
        if (initialType.startsWith(`${this.inputTypes.ARRAY}_of_`)) {
            // Add base types first
            Object.values(this.inputTypes).forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                if (type === this.inputTypes.ARRAY) option.selected = true;
                select.appendChild(option);
            });

            // Create inner type selector only if array is selected
            const innerType = initialType.split('_of_')[1];
            const itemTypeSelect = document.createElement('select');
            itemTypeSelect.className = 'form-select mb-2';

            // Populate inner type options
            Object.values(this.inputTypes).forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = `Item Type: ${type.charAt(0).toUpperCase() + type.slice(1)}`;
                if (type === innerType) option.selected = true;
                itemTypeSelect.appendChild(option);
            });

            // Event listener for main type changes
            select.addEventListener('change', (e) => {
                const newType = e.target.value;
                
                // Remove existing input
                if (currentInputElement) {
                    container.removeChild(currentInputElement);
                }

                if (newType === this.inputTypes.ARRAY) {
                    // Show inner type selector only when array is selected
                    if (!itemTypeSelect.parentNode) {
                        container.insertBefore(itemTypeSelect, currentInputElement);
                    }
                    // Update current type to array with inner type
                    currentInputType = `${this.inputTypes.ARRAY}_of_${itemTypeSelect.value}`;
                } else {
                    // Remove inner type selector if array is not selected
                    if (itemTypeSelect.parentNode) {
                        container.removeChild(itemTypeSelect);
                    }
                    currentInputType = newType;
                }

                // Create new input based on current type
                currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);
                container.appendChild(currentInputElement);
            });

            // Event listener for inner type changes
            itemTypeSelect.addEventListener('change', (e) => {
                const newInnerType = e.target.value;
                currentInputType = `${this.inputTypes.ARRAY}_of_${newInnerType}`;
                
                // Remove existing input
                if (currentInputElement) {
                    container.removeChild(currentInputElement);
                }

                // Create new input based on selected type
                currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);
                container.appendChild(currentInputElement);
            });

            return { select, itemTypeSelect };
        }

        // Regular type selector for non-array types
        Object.values(this.inputTypes).forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            if (type === initialType) option.selected = true;
            select.appendChild(option);
        });

        select.addEventListener('change', (e) => {
            const newType = e.target.value;
            
            // Remove existing input
            if (currentInputElement) {
                container.removeChild(currentInputElement);
            }

            // Create new input based on selected type
            currentInputType = newType;
            currentInputElement = this.createInputBasedOnType(newType, defaultValue);
            container.appendChild(currentInputElement);
        });

        return { select };
    }

    // ... (rest of the class remains the same)
}