class ConfigInputHandler {
    // ... (previous methods remain the same until createDynamicInput)

    // Create dynamic input with card wrapper
    createDynamicInput(fieldName, fieldConfig) {
        const { default: defaultValue, required, ui_displayed_name, example } = fieldConfig;
        
        // Container for the entire input
        const container = document.createElement('div');
        container.className = 'dynamic-input-wrapper';

        // Label
        const label = document.createElement('label');
        label.htmlFor = fieldName;
        label.className = `form-label ${required !== false ? 'required-label' : ''}`;
        label.textContent = `${ui_displayed_name} ${required !== false ? '(required)' : '(optional)'}`;

        // Current input type
        let currentInputType = this.detectInputType(defaultValue);
        let currentInputElement;

        // Create type selector to handle nested array types
        const select = document.createElement('select');
        select.className = 'form-select mb-2';
        let itemTypeSelect = null;

        // Handle array types
        if (currentInputType.startsWith(`${this.inputTypes.ARRAY}_of_`)) {
            // Add base types first
            Object.values(this.inputTypes).forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                if (type === this.inputTypes.ARRAY) option.selected = true;
                select.appendChild(option);
            });

            // Create inner type selector
            const innerType = currentInputType.split('_of_')[1];
            itemTypeSelect = document.createElement('select');
            itemTypeSelect.className = 'form-select mb-2';

            // Populate inner type options
            Object.values(this.inputTypes).forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = `Item Type: ${type.charAt(0).toUpperCase() + type.slice(1)}`;
                if (type === innerType) option.selected = true;
                itemTypeSelect.appendChild(option);
            });

            // Event listener for main type changes
            select.addEventListener('change', (e) => {
                const newType = e.target.value;
                
                // Remove existing input
                if (currentInputElement) {
                    container.removeChild(currentInputElement);
                }

                if (newType === this.inputTypes.ARRAY) {
                    // Show inner type selector only when array is selected
                    if (!itemTypeSelect.parentNode) {
                        container.insertBefore(itemTypeSelect, currentInputElement);
                    }
                    // Update current type to array with inner type
                    currentInputType = `${this.inputTypes.ARRAY}_of_${itemTypeSelect.value}`;
                } else {
                    // Remove inner type selector if array is not selected
                    if (itemTypeSelect.parentNode) {
                        container.removeChild(itemTypeSelect);
                    }
                    currentInputType = newType;
                }

                // Create new input based on current type
                currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);
                container.appendChild(currentInputElement);
            });

            // Event listener for inner type changes
            itemTypeSelect.addEventListener('change', (e) => {
                const newInnerType = e.target.value;
                currentInputType = `${this.inputTypes.ARRAY}_of_${newInnerType}`;
                
                // Remove existing input
                if (currentInputElement) {
                    container.removeChild(currentInputElement);
                }

                // Create new input based on selected type
                currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);
                container.appendChild(currentInputElement);
            });
        } else {
            // Regular type selector for non-array types
            Object.values(this.inputTypes).forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                if (type === currentInputType) option.selected = true;
                select.appendChild(option);
            });

            select.addEventListener('change', (e) => {
                const newType = e.target.value;
                
                // Remove existing input
                if (currentInputElement) {
                    container.removeChild(currentInputElement);
                }

                // Create new input based on selected type
                currentInputType = newType;
                currentInputElement = this.createInputBasedOnType(newType, defaultValue);
                container.appendChild(currentInputElement);
            });
        }

        // Initial input
        currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);

        // Combine elements
        container.appendChild(label);
        container.appendChild(select);
        if (itemTypeSelect) {
            container.appendChild(itemTypeSelect);
        }
        container.appendChild(currentInputElement);

        // Wrap in a card
        return this.createCardWrapper(ui_displayed_name, container);
    }

    // ... (rest of the class remains the same)
}