{% extends "generate_config/base.html" %}
{% load static %}

{% block content %}

<div class="container-fluid px-4 mt-5">
    <h2 class="mb-4">Generate Configuration</h2>
    
    <div class="card shadow-sm mb-4">
        <div class="card-header bg-primary text-white">
            <h5 class="card-title mb-0">Select Configuration</h5>
        </div>
        <div class="card-body">
            <form id="configSelectionForm" method="GET" action="{% url 'generate_config:generate_config' %}">
                <div class="mb-3">
                    <label for="configDropdown" class="form-label">Choose Configuration</label>
                    <select class="form-select optimized-select" id="configDropdown" name="config_type" required>
                        <option value="">Select Configuration Type</option>
                        {% for config in configs_list %}
                        <option value="{{ config.name }}">{{ config.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="d-grid">
                    <button type="submit" class="btn btn-primary">
                        Show Configuration
                        <i class="bi bi-arrow-right-circle ms-2"></i>
                    </button>
                </div>
            </form>

            <!-- Add loading spinner -->
            <div id="loadingSpinner" class="text-center mt-3" style="display: none;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2 text-primary">Loading configuration...</p>
            </div>
        </div>
    </div>

    <div class="card shadow-sm mb-4">
        <div class="card-body" id="configFormContainer" style="display: none;">
            <form id="configGenerationForm" method="POST" action="{% url 'generate_config:generate_config' %}">
                {% csrf_token %}
                <div id="dynamicFields" class="row g-3"></div>
                <input type="hidden" id="parsedData" name="parsedData">
                <div class="mt-4">
                    <button type="submit" class="btn btn-primary">Generate Config</button>
                    <button type="reset" class="btn btn-secondary ms-2">Reset</button>
                </div>
            </form>
        </div>
    </div>
    
</div>

<style>
    /*
    #loadingSpinner {
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }
     */

    /*
    #loadingSpinner {
        transition: display 0.3s ease-in-out;
    }
    */
    
    /*
    #loadingSpinner.show {
        opacity: 1;
    }
    
    #configFormContainer {
        transition: display 0.3s ease-in-out;
    }
    
    .spinner-border {
        width: 3rem;
        height: 3rem;
    }
    */
</style>

<style>
    /* Full-screen loading overlay */
    #fullScreenLoader {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
        z-index: 9999; /* Ensure it's on top of everything */
        display: flex;
        justify-content: center;
        align-items: center;
    }

    #fullScreenLoader .spinner-container {
        background-color: white;
        padding: 2rem;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #fullScreenLoader .spinner-border {
        width: 4rem;
        height: 4rem;
        border-width: 0.25em;
    }

    #fullScreenLoader .loading-text {
        margin-top: 1rem;
        color: #333;
        font-weight: bold;
    }
</style>

<style>
    .required-label::after {
        content: " *";
        color: red;
    }
    .form-text.text-muted {
        color: #6c757d !important;
        word-wrap: break-word;
        overflow-wrap: break-word;
        white-space: normal;
        width: 100%;
        display: block;
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
        .container-fluid {
            padding-left: 10px !important;
            padding-right: 10px !important;
        }
        
        #dynamicFields .col-md-6 {
            flex: 0 0 100%;
            max-width: 100%;
        }
        
        .btn {
            margin-bottom: 10px;
            width: 100%;
        }
        
        .btn:not(:first-child) {
            margin-left: 0 !important;
        }
        
        h2 {
            font-size: 1.5rem;
        }
        
        .form-control {
            font-size: 14px;
        }
        
        .form-text.text-muted {
            font-size: 12px;
        }
    }

    /* Ensure textarea and inputs are consistent */
    textarea.form-control, input.form-control {
        min-height: 38px;
    }
</style>

<style>
    .optimized-select-wrapper {
        position: relative;
        width: 100%;
    }
    
    .optimized-select-button {
        width: 100%;
        text-align: left;
        cursor: pointer;
    }
    
    .optimized-select-dropdown {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 1000;
        margin-top: 0.25rem;
    }
    
    .optimized-select-search {
        width: 100%;
        padding: 0.5rem;
        border-bottom: 1px solid #dee2e6;
        border-radius: 0.375rem 0.375rem 0 0;
    }
    
    .optimized-select-options {
        overflow-y: auto;
        position: relative;
        border-radius: 0 0 0.375rem 0.375rem;
    }
    
    .virtual-scroll-container {
        position: relative;
    }
    
    .optimized-select-option {
        padding: 0.5rem 1rem;
        cursor: pointer;
        position: absolute;
        width: 100%;
        display: flex;
        align-items: center;
    }
    
    .optimized-select-option:hover {
        background-color: #f8f9fa;
    }
    
    .optimized-select-options::-webkit-scrollbar {
        width: 6px;
    }
    
    .optimized-select-options::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 3px;
    }
    
    .optimized-select-options::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 3px;
    }
    
    .optimized-select-options::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
</style>

<script>
    // Custom select with virtual scrolling and search that can be reused
    class OptimizedSelect {
        constructor(originalSelect, options = {}) {
            if(originalSelect.dataset.initialized){
                return;
            }

          this.originalSelect = originalSelect;
          this.options = options;
          this.itemHeight = 35;
          this.visibleItems = 8;
          this.allOptions = Array.from(originalSelect.options).map(opt => ({
            value: opt.value,
            label: opt.text
          }));
          this.isOpen = false;

          originalSelect.dataset.initialized = 'true';
      
          this.init();
        }
      
        init() {
          // Create wrapper
          this.wrapper = document.createElement('div');
          this.wrapper.className = 'optimized-select-wrapper';
          this.wrapper.id = `${this.elementId}-wrapper`;
      
          // Create custom select button
          this.button = document.createElement('button');
          this.button.className = 'optimized-select-button form-select';
          this.button.id = `${this.elementId}-button`;
          this.button.type = 'button'; // Prevent form submission
          this.button.textContent = this.originalSelect.selectedOptions[0]?.text || 'Choose...';
      
          // Create dropdown container
          this.dropdown = document.createElement('div');
          this.dropdown.className = 'optimized-select-dropdown';
          this.dropdown.id = `${this.elementId}-dropdown`;
      
          // Create search input
          this.searchInput = document.createElement('input');
          this.searchInput.className = 'optimized-select-search form-control';
          this.searchInput.id = `${this.elementId}-search`;
          this.searchInput.placeholder = 'Search...';
      
          // Create options container
          this.optionsContainer = document.createElement('div');
          this.optionsContainer.className = 'optimized-select-options';
          this.optionsContainer.id = `${this.elementId}-options`;
          this.optionsContainer.style.height = `${this.itemHeight * this.visibleItems}px`;
      
          // Create virtual scroll container
          this.virtualScroll = document.createElement('div');
          this.virtualScroll.className = 'virtual-scroll-container';
          this.virtualScroll.id = `${this.elementId}-virtual-scroll`;
      
          // Assemble the components
          this.dropdown.appendChild(this.searchInput);
          this.dropdown.appendChild(this.optionsContainer);
          this.optionsContainer.appendChild(this.virtualScroll);
          this.wrapper.appendChild(this.button);
          this.wrapper.appendChild(this.dropdown);
      
          // Insert custom select after original
          this.originalSelect.style.display = 'none';
          this.originalSelect.parentNode.insertBefore(this.wrapper, this.originalSelect.nextSibling);
      
          this.addEventListeners();
          this.filterAndRenderOptions();
        }
      
        addEventListeners() {
          // Toggle dropdown with improved handling
          this.button.addEventListener('mousedown', (e) => {
            e.preventDefault(); // Prevent focus issues
            this.toggleDropdown();
          });
      
          // Handle search
          this.searchInput.addEventListener('input', () => {
            this.filterAndRenderOptions();
          });
      
          // Prevent search input from closing dropdown
          this.searchInput.addEventListener('mousedown', (e) => {
            e.stopPropagation();
          });
      
          // Handle scroll
          this.optionsContainer.addEventListener('scroll', () => {
            this.renderVisibleOptions();
          });
      
          // Close dropdown when clicking outside
          document.addEventListener('mousedown', (e) => {
            if (!this.wrapper.contains(e.target)) {
              this.closeDropdown();
            }
          });
      
          // Prevent dropdown from closing when clicking inside
          this.dropdown.addEventListener('mousedown', (e) => {
            e.stopPropagation();
          });
        }
      
        toggleDropdown() {
          if (this.isOpen) {
            this.closeDropdown();
          } else {
            this.openDropdown();
          }
        }
      
        openDropdown() {
          this.isOpen = true;
          this.dropdown.style.display = 'block';
          this.searchInput.focus();
          this.filterAndRenderOptions();
        }
      
        closeDropdown() {
          this.isOpen = false;
          this.dropdown.style.display = 'none';
          this.searchInput.value = '';
          this.filterAndRenderOptions();
        }
      
        filterAndRenderOptions() {
          const searchTerm = this.searchInput.value.toLowerCase();
          this.filteredOptions = this.allOptions.filter(option => 
            option.label.toLowerCase().includes(searchTerm)
          );
      
          // Reset scroll position
          this.optionsContainer.scrollTop = 0;
          this.virtualScroll.style.height = `${this.filteredOptions.length * this.itemHeight}px`;
          this.renderVisibleOptions();
        }
      
        renderVisibleOptions() {
          const scrollTop = this.optionsContainer.scrollTop;
          const startIndex = Math.floor(scrollTop / this.itemHeight);
          const endIndex = startIndex + this.visibleItems + 2;
      
          this.virtualScroll.innerHTML = '';
      
          this.filteredOptions.slice(startIndex, endIndex).forEach((option, index) => {
            const optionEl = document.createElement('div');
            optionEl.className = 'optimized-select-option';
            optionEl.textContent = option.label;
            optionEl.style.position = 'absolute';
            optionEl.style.top = `${(startIndex + index) * this.itemHeight}px`;
            optionEl.style.height = `${this.itemHeight}px`;
      
            optionEl.addEventListener('mousedown', (e) => {
              e.preventDefault(); // Prevent focus issues
              this.selectOption(option);
            });
      
            this.virtualScroll.appendChild(optionEl);
          });
        }
      
        selectOption(option) {
          // Update original select
          this.originalSelect.value = option.value;
          this.originalSelect.dispatchEvent(new Event('change'));
      
          // Update custom select
          this.button.textContent = option.label;
          this.closeDropdown();
        }
      }
</script>

<script>
    class ConfigInputHandler {
        constructor(containerSelector) {
            this.container = document.querySelector(containerSelector);
            this.inputTypes = {
                STRING: 'string',
                ARRAY: 'array',
                OBJECT: 'object',
                BOOLEAN: 'boolean',
                NUMBER: 'number'
            };
        }
    
        // Create card wrapper for inputs
        createCardWrapper(title, content) {
            const card = document.createElement('div');
            card.className = 'card mb-3 shadow-sm';
    
            const cardHeader = document.createElement('div');
            cardHeader.className = 'card-header bg-light d-flex justify-content-between align-items-center';
            cardHeader.textContent = title;
    
            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';
            cardBody.appendChild(content);
    
            card.appendChild(cardHeader);
            card.appendChild(cardBody);
    
            return card;
        }
    
        // Create reorderable list
        createArrayInput(defaultValue, onChangeCallback) {
            const container = document.createElement('div');
            container.className = 'reorderable-list-container';
    
            // List to store array values
            const arrayValues = Array.isArray(defaultValue) ? [...defaultValue] : [];
    
            // Function to render array items
            const renderArrayItems = () => {
                container.innerHTML = ''; // Clear existing items
                
                arrayValues.forEach((value, index) => {
                    const itemWrapper = document.createElement('div');
                    itemWrapper.className = 'input-group mb-2 align-items-center';
    
                    // Move up button
                    const moveUpBtn = document.createElement('button');
                    moveUpBtn.className = 'btn btn-outline-secondary me-1';
                    moveUpBtn.innerHTML = '↑';
                    moveUpBtn.type = 'button';
                    moveUpBtn.disabled = index === 0;
                    moveUpBtn.addEventListener('click', () => {
                        // Swap current item with the one above
                        [arrayValues[index], arrayValues[index-1]] = [arrayValues[index-1], arrayValues[index]];
                        renderArrayItems();
                        onChangeCallback(arrayValues);
                    });
    
                    // Move down button
                    const moveDownBtn = document.createElement('button');
                    moveDownBtn.className = 'btn btn-outline-secondary me-2';
                    moveDownBtn.innerHTML = '↓';
                    moveDownBtn.type = 'button';
                    moveDownBtn.disabled = index === arrayValues.length - 1;
                    moveDownBtn.addEventListener('click', () => {
                        // Swap current item with the one below
                        [arrayValues[index], arrayValues[index+1]] = [arrayValues[index+1], arrayValues[index]];
                        renderArrayItems();
                        onChangeCallback(arrayValues);
                    });
    
                    // Input for list item
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'form-control';
                    input.value = value?.toString() || '';
    
                    // Update value in arrayValues
                    input.addEventListener('input', (e) => {
                        arrayValues[index] = e.target.value;
                        onChangeCallback(arrayValues);
                    });
    
                    // Remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger ms-2';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.type = 'button';
                    removeBtn.addEventListener('click', () => {
                        arrayValues.splice(index, 1);
                        renderArrayItems();
                        onChangeCallback(arrayValues);
                    });
    
                    // Assemble item
                    itemWrapper.appendChild(moveUpBtn);
                    itemWrapper.appendChild(moveDownBtn);
                    itemWrapper.appendChild(input);
                    itemWrapper.appendChild(removeBtn);
    
                    container.appendChild(itemWrapper);
                });
    
                // Add new item button
                const addBtn = document.createElement('button');
                addBtn.className = 'btn btn-primary mt-2';
                addBtn.textContent = 'Add Item';
                addBtn.type = 'button';
                addBtn.addEventListener('click', () => {
                    arrayValues.push('');
                    renderArrayItems();
                    onChangeCallback(arrayValues);
                });
    
                container.appendChild(addBtn);
            };
    
            renderArrayItems();
            return container;
        }
    
        // Existing methods for other input types (simplified)
        createInputTypeSelector(currentType, onChangeCallback) {
            const select = document.createElement('select');
            select.className = 'form-select mb-2';
    
            Object.values(this.inputTypes).forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                if (type === currentType) option.selected = true;
                select.appendChild(option);
            });
    
            select.addEventListener('change', (e) => {
                onChangeCallback(e.target.value);
            });
    
            return select;
        }
    
        // Simplified methods for other input types
        createStringInput(defaultValue, onChangeCallback) {
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-control';
            input.value = defaultValue?.toString() || '';
            input.addEventListener('input', (e) => {
                onChangeCallback(e.target.value);
            });
            return input;
        }
    
        createBooleanInput(defaultValue, onChangeCallback) {
            const select = document.createElement('select');
            select.className = 'form-select';
    
            ['true', 'false'].forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value.charAt(0).toUpperCase() + value.slice(1);
                if (value === defaultValue.toString()) option.selected = true;
                select.appendChild(option);
            });
    
            select.addEventListener('change', (e) => {
                onChangeCallback(e.target.value === 'true');
            });
    
            return select;
        }
    
        createNumberInput(defaultValue, onChangeCallback) {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = 'form-control';
            input.value = defaultValue || 0;
            input.addEventListener('input', (e) => {
                onChangeCallback(Number(e.target.value));
            });
            return input;
        }
    
        createObjectInput(defaultValue, onChangeCallback) {
            const container = document.createElement('div');
            container.className = 'object-input-container';
    
            // List to store object key-value pairs
            const objectValues = typeof defaultValue === 'object' && defaultValue !== null 
                ? Object.entries(defaultValue).map(([k, v]) => ({ key: k, value: v })) 
                : [];
    
            // Function to render object items
            const renderObjectItems = () => {
                container.innerHTML = ''; // Clear existing items
                
                objectValues.forEach((item, index) => {
                    const itemWrapper = document.createElement('div');
                    itemWrapper.className = 'input-group mb-2';
    
                    // Key input
                    const keyInput = document.createElement('input');
                    keyInput.type = 'text';
                    keyInput.className = 'form-control';
                    keyInput.placeholder = 'Key';
                    keyInput.value = item.key;
    
                    // Value input
                    const valueInput = document.createElement('input');
                    valueInput.type = 'text';
                    valueInput.className = 'form-control';
                    valueInput.placeholder = 'Value';
                    valueInput.value = item.value?.toString() || '';
    
                    // Update key
                    keyInput.addEventListener('input', (e) => {
                        objectValues[index].key = e.target.value;
                        onChangeCallback(objectValues.reduce((acc, curr) => {
                            if (curr.key) acc[curr.key] = curr.value;
                            return acc;
                        }, {}));
                    });
    
                    // Update value
                    valueInput.addEventListener('input', (e) => {
                        objectValues[index].value = e.target.value;
                        onChangeCallback(objectValues.reduce((acc, curr) => {
                            if (curr.key) acc[curr.key] = curr.value;
                            return acc;
                        }, {}));
                    });
    
                    // Remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.addEventListener('click', () => {
                        objectValues.splice(index, 1);
                        renderObjectItems();
                        onChangeCallback(objectValues.reduce((acc, curr) => {
                            if (curr.key) acc[curr.key] = curr.value;
                            return acc;
                        }, {}));
                    });
    
                    itemWrapper.appendChild(keyInput);
                    itemWrapper.appendChild(valueInput);
                    itemWrapper.appendChild(removeBtn);
                    container.appendChild(itemWrapper);
                });
    
                // Add new item button
                const addBtn = document.createElement('button');
                addBtn.className = 'btn btn-primary mt-2';
                addBtn.textContent = 'Add Key-Value Pair';
                addBtn.addEventListener('click', () => {
                    objectValues.push({ key: '', value: '' });
                    renderObjectItems();
                });
    
                container.appendChild(addBtn);
            };
    
            renderObjectItems();
            return container;
        }
    
        // Detect input type based on default value
        // Recursive type detection for nested structures
        detectInputType(defaultValue) {
            if (defaultValue === null) return this.inputTypes.STRING;
        
            if (Array.isArray(defaultValue)) {
                // If array is empty, return base array type
                if (defaultValue.length === 0) return this.inputTypes.ARRAY;
                
                const firstItem = defaultValue[0];
                
                // Specifically handle primitive and complex types
                if (firstItem === null) return `${this.inputTypes.ARRAY}_of_${this.inputTypes.STRING}`;
                
                if (Array.isArray(firstItem)) {
                    return `${this.inputTypes.ARRAY}_of_${this.inputTypes.ARRAY}`;
                }
                
                if (typeof firstItem === 'object') {
                    return `${this.inputTypes.ARRAY}_of_${this.inputTypes.OBJECT}`;
                }
                
                // For primitive types
                return `${this.inputTypes.ARRAY}_of_${typeof firstItem}`;
            }
            
            if (typeof defaultValue === 'object') {
                // Check if it's a plain object with nested structures
                const objectEntries = Object.entries(defaultValue);
                if (objectEntries.length === 0) return this.inputTypes.OBJECT;
                
                // Check if any value is complex
                const hasComplexValue = objectEntries.some(([_, val]) => 
                    Array.isArray(val) || (typeof val === 'object' && val !== null)
                );
                
                return hasComplexValue ? `${this.inputTypes.OBJECT}_with_complex_values` : this.inputTypes.OBJECT;
            }
            
            if (typeof defaultValue === 'boolean') return this.inputTypes.BOOLEAN;
            if (typeof defaultValue === 'number') return this.inputTypes.NUMBER;
            
            return this.inputTypes.STRING;
        }

        // Method to detect individual item type
        detectItemType(item) {
            if (item === null) return 'primitive';
            if (Array.isArray(item)) return this.inputTypes.ARRAY;
            if (typeof item === 'object') return this.inputTypes.OBJECT;
            return typeof item;
        }
    
        // Create input based on type
        // Recursive input creation for nested structures
        createInputBasedOnType(type, defaultValue, depth = 0) {
            const MAX_DEPTH = 3;
            if (depth > MAX_DEPTH) {
                console.warn('Maximum nesting depth reached');
                return this.createStringInput(JSON.stringify(defaultValue), () => {});
            }
    
            const onChangeCallback = (value) => {
                console.log('Value changed:', value);
            };
    
            // Handle array of specific types
            if (type.startsWith(`${this.inputTypes.ARRAY}_of_`)) {
                const itemType = type.split('_of_')[1];
                return this.createNestedArrayInput(
                    defaultValue, 
                    onChangeCallback, 
                    depth, 
                    itemType
                );
            }
    
            // Handle complex nested objects
            if (type === `${this.inputTypes.OBJECT}_with_complex_values`) {
                return this.createNestedObjectInput(
                    defaultValue, 
                    onChangeCallback, 
                    depth
                );
            }
    
            // Original type handling remains the same
            switch(type) {
                case this.inputTypes.STRING:
                    return this.createStringInput(defaultValue, onChangeCallback);
                case this.inputTypes.ARRAY:
                    return this.createNestedArrayInput(defaultValue, onChangeCallback, depth);
                case this.inputTypes.OBJECT:
                    return this.createNestedObjectInput(defaultValue, onChangeCallback, depth);
                case this.inputTypes.BOOLEAN:
                    return this.createBooleanInput(defaultValue, onChangeCallback);
                case this.inputTypes.NUMBER:
                    return this.createNumberInput(defaultValue, onChangeCallback);
                default:
                    return this.createStringInput(defaultValue, onChangeCallback);
            }
        }

        // Enhanced array input to handle nested arrays
        createNestedArrayInput(defaultValue, onChangeCallback, depth, itemType = null) {
            const container = document.createElement('div');
            container.className = 'nested-array-container';
    
            const arrayValues = Array.isArray(defaultValue) ? [...defaultValue] : [];
    
            const renderArrayItems = () => {
                container.innerHTML = '';
                
                arrayValues.forEach((value, index) => {
                    const itemWrapper = document.createElement('div');
                    itemWrapper.className = 'nested-array-item input-group mb-2';
    
                    // Detect or use provided item type
                    const detectedItemType = itemType || this.detectItemType(value);
                    let currentItemType = detectedItemType === 'primitive' 
                        ? this.detectInputType(value) 
                        : detectedItemType;
    
                    // Type selector for array elements
                    const typeSelector = this.createInputTypeSelector(currentItemType, (newType) => {
                        // Reset the value based on the new type
                        switch(newType) {
                            case this.inputTypes.STRING:
                                arrayValues[index] = '';
                                break;
                            case this.inputTypes.NUMBER:
                                arrayValues[index] = 0;
                                break;
                            case this.inputTypes.BOOLEAN:
                                arrayValues[index] = false;
                                break;
                            case this.inputTypes.ARRAY:
                                arrayValues[index] = [];
                                break;
                            case this.inputTypes.OBJECT:
                                arrayValues[index] = {};
                                break;
                        }
                        
                        // Update type and re-render items
                        currentItemType = newType;
                        renderArrayItems();
                        onChangeCallback(arrayValues);
                    });
    
                    // Input based on detected/selected type
                    const itemInput = this.createInputBasedOnType(
                        currentItemType, 
                        value, 
                        depth + 1
                    );
    
                    // Update value handling
                    itemInput.addEventListener('change', (e) => {
                        arrayValues[index] = e.target.value;
                        onChangeCallback(arrayValues);
                    });
    
                    // Remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger ms-2';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.addEventListener('click', () => {
                        arrayValues.splice(index, 1);
                        renderArrayItems();
                        onChangeCallback(arrayValues);
                    });
    
                    // Assemble item wrapper
                    itemWrapper.appendChild(typeSelector);
                    itemWrapper.appendChild(itemInput);
                    itemWrapper.appendChild(removeBtn);
    
                    container.appendChild(itemWrapper);
                });
    
                // Add new item button
                const addBtn = document.createElement('button');
                addBtn.className = 'btn btn-primary mt-2';
                addBtn.textContent = 'Add Item';
                addBtn.addEventListener('click', () => {
                    arrayValues.push(''); // Default to empty string
                    renderArrayItems();
                    onChangeCallback(arrayValues);
                });
    
                container.appendChild(addBtn);
            };
    
            renderArrayItems();
            return container;
        }
    
        // Enhanced object input to handle nested objects
        createNestedObjectInput(defaultValue, onChangeCallback, depth) {
            const container = document.createElement('div');
            container.className = 'nested-object-container';
    
            // Ensure defaultValue is an object
            const objectValues = typeof defaultValue === 'object' && defaultValue !== null 
                ? Object.entries(defaultValue).map(([k, v]) => ({ key: k, value: v })) 
                : [];
    
            const renderObjectItems = () => {
                container.innerHTML = ''; // Clear existing items
                
                objectValues.forEach((item, index) => {
                    const itemWrapper = document.createElement('div');
                    itemWrapper.className = 'nested-object-item input-group mb-2';
    
                    // Key input
                    const keyInput = document.createElement('input');
                    keyInput.type = 'text';
                    keyInput.className = 'form-control me-2';
                    keyInput.placeholder = 'Key';
                    keyInput.value = item.key;
    
                    // Detect type for this specific object value
                    const valueType = this.detectInputType(item.value);
    
                    // Input type selector for nested values
                    const typeSelector = this.createInputTypeSelector(valueType, (newType) => {
                        // Reset the value based on the new type
                        switch(newType) {
                            case this.inputTypes.STRING:
                                objectValues[index].value = '';
                                break;
                            case this.inputTypes.NUMBER:
                                objectValues[index].value = 0;
                                break;
                            case this.inputTypes.BOOLEAN:
                                objectValues[index].value = false;
                                break;
                            case this.inputTypes.ARRAY:
                                objectValues[index].value = [];
                                break;
                            case this.inputTypes.OBJECT:
                                objectValues[index].value = {};
                                break;
                        }
                        renderObjectItems();
                        onChangeCallback(objectValues.reduce((acc, curr) => {
                            if (curr.key) acc[curr.key] = curr.value;
                            return acc;
                        }, {}));
                    });
    
                    // Create value input based on detected type
                    const valueInput = this.createInputBasedOnType(valueType, item.value, depth + 1);
    
                    // Update key and value events
                    keyInput.addEventListener('input', (e) => {
                        objectValues[index].key = e.target.value;
                        onChangeCallback(objectValues.reduce((acc, curr) => {
                            if (curr.key) acc[curr.key] = curr.value;
                            return acc;
                        }, {}));
                    });
    
                    if (valueInput) {
                        valueInput.addEventListener('change', (e) => {
                            objectValues[index].value = e.target.value;
                            onChangeCallback(objectValues.reduce((acc, curr) => {
                                if (curr.key) acc[curr.key] = curr.value;
                                return acc;
                            }, {}));
                        });
                    }
    
                    // Remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger ms-2';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.addEventListener('click', () => {
                        objectValues.splice(index, 1);
                        renderObjectItems();
                        onChangeCallback(objectValues.reduce((acc, curr) => {
                            if (curr.key) acc[curr.key] = curr.value;
                            return acc;
                        }, {}));
                    });
    
                    // Assemble item
                    itemWrapper.appendChild(keyInput);
                    itemWrapper.appendChild(typeSelector);
                    itemWrapper.appendChild(valueInput);
                    itemWrapper.appendChild(removeBtn);
    
                    container.appendChild(itemWrapper);
                });
    
                // Add new item button
                const addBtn = document.createElement('button');
                addBtn.className = 'btn btn-primary mt-2';
                addBtn.textContent = 'Add Key-Value Pair';
                addBtn.addEventListener('click', () => {
                    objectValues.push({ key: '', value: '' });
                    renderObjectItems();
                });
    
                container.appendChild(addBtn);
            };
    
            renderObjectItems();
            return container;
        }
    
        // Create dynamic input with card wrapper
        createDynamicInput(fieldName, fieldConfig) {
            const { default: defaultValue, required, ui_displayed_name, example } = fieldConfig;
            
            // Container for the entire input
            const container = document.createElement('div');
            container.className = 'dynamic-input-wrapper';
    
            // Label
            const label = document.createElement('label');
            label.htmlFor = fieldName;
            label.className = `form-label ${required !== false ? 'required-label' : ''}`;
            label.textContent = `${ui_displayed_name} ${required !== false ? '(required)' : '(optional)'}`;
    
            // Current input type
            let currentInputType = this.detectInputType(defaultValue);
            let currentInputElement;
    
            // Create type selector to handle nested array types
            const select = document.createElement('select');
            select.className = 'form-select mb-2';
            let itemTypeSelect = null;
    
            // Handle array types
            if (currentInputType.startsWith(`${this.inputTypes.ARRAY}_of_`)) {
                // Add base types first
                Object.values(this.inputTypes).forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    if (type === this.inputTypes.ARRAY) option.selected = true;
                    select.appendChild(option);
                });
    
                // Create inner type selector
                const innerType = currentInputType.split('_of_')[1];
                itemTypeSelect = document.createElement('select');
                itemTypeSelect.className = 'form-select mb-2';
    
                // Populate inner type options
                Object.values(this.inputTypes).forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = `Item Type: ${type.charAt(0).toUpperCase() + type.slice(1)}`;
                    if (type === innerType) option.selected = true;
                    itemTypeSelect.appendChild(option);
                });
    
                // Event listener for main type changes
                select.addEventListener('change', (e) => {
                    const newType = e.target.value;
                    
                    // Remove existing input
                    if (currentInputElement) {
                        container.removeChild(currentInputElement);
                    }
    
                    if (newType === this.inputTypes.ARRAY) {
                        // Show inner type selector only when array is selected
                        if (!itemTypeSelect.parentNode) {
                            container.insertBefore(itemTypeSelect, currentInputElement);
                        }
                        // Update current type to array with inner type
                        currentInputType = `${this.inputTypes.ARRAY}_of_${itemTypeSelect.value}`;
                    } else {
                        // Remove inner type selector if array is not selected
                        if (itemTypeSelect.parentNode) {
                            container.removeChild(itemTypeSelect);
                        }
                        currentInputType = newType;
                    }
    
                    // Create new input based on current type
                    currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);
                    container.appendChild(currentInputElement);
                });
    
                // Event listener for inner type changes
                itemTypeSelect.addEventListener('change', (e) => {
                    const newInnerType = e.target.value;
                    currentInputType = `${this.inputTypes.ARRAY}_of_${newInnerType}`;
                    
                    // Remove existing input
                    if (currentInputElement) {
                        container.removeChild(currentInputElement);
                    }
    
                    // Create new input based on selected type
                    currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);
                    container.appendChild(currentInputElement);
                });
            } else {
                // Regular type selector for non-array types
                Object.values(this.inputTypes).forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    if (type === currentInputType) option.selected = true;
                    select.appendChild(option);
                });
    
                select.addEventListener('change', (e) => {
                    const newType = e.target.value;
                    
                    // Remove existing input
                    if (currentInputElement) {
                        container.removeChild(currentInputElement);
                    }
    
                    // Create new input based on selected type
                    currentInputType = newType;
                    currentInputElement = this.createInputBasedOnType(newType, defaultValue);
                    container.appendChild(currentInputElement);
                });
            }
    
            // Initial input
            currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);
    
            // Combine elements
            container.appendChild(label);
            container.appendChild(select);
            if (itemTypeSelect) {
                //container.appendChild(itemTypeSelect);
            }
            container.appendChild(currentInputElement);
    
            // Wrap in a card
            return this.createCardWrapper(ui_displayed_name, container);
        }
    }
</script>


<script>
    // Function to render the configuration form
    function renderConfigurationForm(configData) {
        const dynamicFieldsContainer = document.getElementById('dynamicFields');
        dynamicFieldsContainer.innerHTML = ''; // Clear existing fields

        // Create input handler
        const inputHandler = new ConfigInputHandler('#dynamicFields');

        // Render fields based on config data
        Object.entries(configData).forEach(([fieldName, fieldConfig]) => {
            if (fieldConfig.show) {
                const dynamicInput = inputHandler.createDynamicInput(fieldName, fieldConfig);
                dynamicFieldsContainer.appendChild(dynamicInput);
            }
        });

        // Show the form container
        document.getElementById('configFormContainer').style.display = 'block';
    }
    
    /*
    const loadingSpinner = document.getElementById('loadingSpinner');
    const configFormContainer = document.getElementById('configFormContainer');

    // Function to show loading state
    function showLoading() {
        loadingSpinner.style.display = 'block';
        // Force a reflow to ensure the transition works
        loadingSpinner.offsetHeight;
        loadingSpinner.classList.add('show');
        configFormContainer.style.display = 'none';
    }

    // Function to hide loading state
    function hideLoading() {
        loadingSpinner.classList.remove('show');
        setTimeout(() => {
            loadingSpinner.style.display = 'none';
        }, 300); // Match the transition duration
    }
    */

    // Function to show full-screen loading
    function showFullScreenLoading(text) {
        // Create full-screen loader if it doesn't exist
        if (!document.getElementById('fullScreenLoader')) {
            const loaderDiv = document.createElement('div');
            loaderDiv.id = 'fullScreenLoader';
            loaderDiv.innerHTML = `
                <div class="spinner-container">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <div class="loading-text">Processing...</div>
                </div>
            `;
            document.body.appendChild(loaderDiv);
        }
        
        // Show the loader
        const fullScreenLoader = document.getElementById('fullScreenLoader');
        fullScreenLoader.style.display = 'flex';
        
        // Update the loading text
        const loadingText = fullScreenLoader.querySelector('.loading-text');
        loadingText.textContent = text || 'Processing...';
    }

    // Function to hide full-screen loading
    function hideFullScreenLoading() {
        const fullScreenLoader = document.getElementById('fullScreenLoader');
        if (fullScreenLoader) {
            fullScreenLoader.style.display = 'none';
        }
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize optimized selects for all elements with the 'optimized-select' class
        document.querySelectorAll('.optimized-select:not([data-modal])').forEach(select => {
            new OptimizedSelect(select);
        });
        // Handle configuration selection form submission
        document.getElementById('configSelectionForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const configType = document.getElementById('configDropdown').value;
            const url = `{% url 'generate_config:generate_config' %}?config_type=${configType}`;

            // Show loading spinner
            // showLoading();

            // Show full-screen loading
            showFullScreenLoading("Loading Configuration...");
    
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                        // hideLoading();
                        hideFullScreenLoading();
                    } else {
                        renderConfigurationForm(data);
                        // hideLoading();
                        hideFullScreenLoading();
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while fetching the configuration.');
                    // hideLoading();
                    hideFullScreenLoading();
                });
        });
    
        // Handle configuration generation form submission
        document.getElementById('configGenerationForm').addEventListener('submit', function(event) {
            event.preventDefault();
    
            const parsedData = {};
            const formElements = this.elements;

            // Add the selected configuration type to parsedData
            const selectedConfig = document.getElementById('configDropdown').value;
            parsedData['config_name'] = selectedConfig;  // Add this line to include the selected configuration
    
            for (let element of formElements) {
                if (element.name && element.name !== 'csrfmiddlewaretoken') {
                    try {
                        // Attempt to parse the input value
                        const value = element.value.trim();
                        
                        if (value.startsWith('[') || value.startsWith('{')) {
                            // Parse JSON for arrays and objects
                            parsedData[element.name] = JSON.parse(value);
                        } else if (value === 'true' || value === 'false' || value === 'True' || value === 'False') {
                            // Parse boolean
                            parsedData[element.name] = (value === 'true' || value === 'True');
                        } else if (!isNaN(value) && value !== '') {
                            // Parse number
                            parsedData[element.name] = Number(value);
                        } else {
                            // Keep as string
                            parsedData[element.name] = value;
                        }
                    } catch (error) {
                        console.error(`Error parsing ${element.name}:`, error);
                        parsedData[element.name] = element.value;
                    }
                }
            }
            
            console.log(JSON.stringify(parsedData))
            /*
            // Show full-screen loading
            showFullScreenLoading("Generating config...");
            
            // Submit via AJAX
            fetch(this.action, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(parsedData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    hideFullScreenLoading();

                    setTimeout(() => {
                        alert('Config generated successfully! \nRedirecting...');
                    }, 1000);
                    
                    // Hard refresh the page
                    window.location.reload();
                } else {
                    alert('Error: ' + data.message);
                }
                hideFullScreenLoading();
            })
            .catch(error => {
                console.error('Error:', error);
                hideFullScreenLoading();
            });
            */
        });
    });
</script>

{% endblock %}
