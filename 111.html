class ConfigInputHandler {
    constructor(containerSelector) {
        this.container = document.querySelector(containerSelector);
        this.inputTypes = {
            STRING: 'string',
            ARRAY: 'array',
            OBJECT: 'object',
            BOOLEAN: 'boolean',
            NUMBER: 'number'
        };
    }

    // Create card wrapper for inputs
    createCardWrapper(title, content) {
        const card = document.createElement('div');
        card.className = 'card mb-3 shadow-sm';

        const cardHeader = document.createElement('div');
        cardHeader.className = 'card-header bg-light d-flex justify-content-between align-items-center';
        cardHeader.textContent = title;

        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';
        cardBody.appendChild(content);

        card.appendChild(cardHeader);
        card.appendChild(cardBody);

        return card;
    }

    // Create reorderable list with nested input support
    createReorderableList(defaultValue, onChangeCallback, allowNestedInput = false) {
        const container = document.createElement('div');
        container.className = 'reorderable-list-container';

        // List to store array values
        const arrayValues = Array.isArray(defaultValue) ? [...defaultValue] : [];

        // Function to create individual list item
        const createListItem = (value, index) => {
            const itemWrapper = document.createElement('div');
            itemWrapper.className = 'input-group mb-2 reorderable-list-item';
            itemWrapper.dataset.index = index;

            // Determine if value is a complex object that needs nested input
            const isComplexValue = typeof value === 'object' && value !== null;

            // Input element (either simple or nested)
            let input;
            if (isComplexValue && allowNestedInput) {
                // Create nested input for complex values
                input = this.createNestedInput(value, (newValue) => {
                    arrayValues[index] = newValue;
                    onChangeCallback(arrayValues);
                });
            } else {
                // Simple input
                input = document.createElement('input');
                input.type = 'text';
                input.className = 'form-control';
                input.value = isComplexValue ? JSON.stringify(value) : value?.toString() || '';

                // Update value in arrayValues
                input.addEventListener('input', (e) => {
                    try {
                        // Try parsing as JSON first
                        arrayValues[index] = JSON.parse(e.target.value);
                    } catch {
                        // If not valid JSON, use as string
                        arrayValues[index] = e.target.value;
                    }
                    onChangeCallback(arrayValues);
                });
            }

            // Move up button
            const moveUpBtn = document.createElement('button');
            moveUpBtn.className = 'btn btn-outline-secondary';
            moveUpBtn.innerHTML = '↑';
            moveUpBtn.addEventListener('click', () => {
                if (index > 0) {
                    // Swap current item with the one above
                    [arrayValues[index], arrayValues[index-1]] = [arrayValues[index-1], arrayValues[index]];
                    renderArrayItems();
                    onChangeCallback(arrayValues);
                }
            });

            // Move down button
            const moveDownBtn = document.createElement('button');
            moveDownBtn.className = 'btn btn-outline-secondary';
            moveDownBtn.innerHTML = '↓';
            moveDownBtn.addEventListener('click', () => {
                if (index < arrayValues.length - 1) {
                    // Swap current item with the one below
                    [arrayValues[index], arrayValues[index+1]] = [arrayValues[index+1], arrayValues[index]];
                    renderArrayItems();
                    onChangeCallback(arrayValues);
                }
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger';
            removeBtn.innerHTML = '&times;';
            removeBtn.addEventListener('click', () => {
                arrayValues.splice(index, 1);
                renderArrayItems();
                onChangeCallback(arrayValues);
            });

            // Assemble item
            itemWrapper.appendChild(moveUpBtn);
            itemWrapper.appendChild(moveDownBtn);
            itemWrapper.appendChild(input);
            itemWrapper.appendChild(removeBtn);

            return itemWrapper;
        };

        // Function to render array items
        const renderArrayItems = () => {
            container.innerHTML = ''; // Clear existing items
            
            arrayValues.forEach((value, index) => {
                const listItem = createListItem(value, index);
                container.appendChild(listItem);
            });

            // Add new item button
            const addBtn = document.createElement('button');
            addBtn.className = 'btn btn-primary mt-2';
            addBtn.textContent = 'Add Item';
            addBtn.addEventListener('click', () => {
                arrayValues.push('');
                renderArrayItems();
            });

            container.appendChild(addBtn);
        };

        renderArrayItems();
        return container;
    }

    // Create nested input for complex values
    createNestedInput(defaultValue, onChangeCallback) {
        // Detect input type for nested input
        const detectNestedType = (value) => {
            if (Array.isArray(value)) return this.inputTypes.ARRAY;
            if (typeof value === 'object' && value !== null) return this.inputTypes.OBJECT;
            if (typeof value === 'boolean') return this.inputTypes.BOOLEAN;
            if (typeof value === 'number') return this.inputTypes.NUMBER;
            return this.inputTypes.STRING;
        };

        const container = document.createElement('div');
        container.className = 'nested-input-container';

        // Create type selector for nested input
        const typeSelector = document.createElement('select');
        typeSelector.className = 'form-select mb-2';
        
        const nestedTypes = [
            this.inputTypes.STRING, 
            this.inputTypes.ARRAY, 
            this.inputTypes.OBJECT, 
            this.inputTypes.BOOLEAN, 
            this.inputTypes.NUMBER
        ];

        let currentNestedType = detectNestedType(defaultValue);

        // Populate type selector
        nestedTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            if (type === currentNestedType) option.selected = true;
            typeSelector.appendChild(option);
        });

        // Nested input container
        const nestedInputContainer = document.createElement('div');

        // Function to create nested input based on type
        const createNestedInputByType = (type, value) => {
            let input;
            switch(type) {
                case this.inputTypes.ARRAY:
                    input = this.createReorderableList(value, (newValue) => {
                        onChangeCallback(newValue);
                    }, true);  // Allow nested input
                    break;
                case this.inputTypes.OBJECT:
                    input = this.createObjectInput(value, (newValue) => {
                        onChangeCallback(newValue);
                    });
                    break;
                case this.inputTypes.BOOLEAN:
                    input = this.createBooleanInput(value, (newValue) => {
                        onChangeCallback(newValue);
                    });
                    break;
                case this.inputTypes.NUMBER:
                    input = this.createNumberInput(value, (newValue) => {
                        onChangeCallback(newValue);
                    });
                    break;
                default:
                    input = this.createStringInput(value, (newValue) => {
                        onChangeCallback(newValue);
                    });
            }
            return input;
        };

        // Initial nested input
        let currentNestedInput = createNestedInputByType(currentNestedType, defaultValue);
        
        // Type selector change event
        typeSelector.addEventListener('change', (e) => {
            const newType = e.target.value;
            
            // Remove existing nested input
            if (currentNestedInput) {
                nestedInputContainer.innerHTML = '';
            }

            // Create new nested input
            currentNestedType = newType;
            currentNestedInput = createNestedInputByType(newType, 
                newType === this.inputTypes.ARRAY ? [] : 
                newType === this.inputTypes.OBJECT ? {} : 
                newType === this.inputTypes.BOOLEAN ? false : 
                newType === this.inputTypes.NUMBER ? 0 : 
                ''
            );
            nestedInputContainer.appendChild(currentNestedInput);
        });

        // Assemble components
        container.appendChild(typeSelector);
        container.appendChild(nestedInputContainer);
        nestedInputContainer.appendChild(currentNestedInput);

        return container;
    }

    // Existing methods remain the same (createArrayInput, createObjectInput, etc.)
    // ... (previous implementation)

    // Updated createDynamicInput to use card wrapper
    createDynamicInput(fieldName, fieldConfig) {
        const { default: defaultValue, required, ui_displayed_name, example } = fieldConfig;
        
        // Container for the entire input
        const container = document.createElement('div');
        container.className = 'dynamic-input-wrapper';

        // Label
        const label = document.createElement('label');
        label.htmlFor = fieldName;
        label.className = `form-label ${required !== false ? 'required-label' : ''}`;
        label.textContent = `${ui_displayed_name} ${required !== false ? '(required)' : '(optional)'}`;

        // Current input type
        let currentInputType = this.detectInputType(defaultValue);
        let currentInputElement;

        // Input type selector
        const typeSelector = this.createInputTypeSelector(currentInputType, (newType) => {
            // Remove existing input
            if (currentInputElement) {
                container.removeChild(currentInputElement);
            }

            // Create new input based on selected type
            currentInputType = newType;
            currentInputElement = this.createInputBasedOnType(newType, defaultValue);
            container.appendChild(currentInputElement);
        });

        // Initial input
        currentInputElement = this.createInputBasedOnType(currentInputType, defaultValue);

        // Combine elements
        container.appendChild(label);
        container.appendChild(typeSelector);
        container.appendChild(currentInputElement);

        // Wrap in a card
        return this.createCardWrapper(ui_displayed_name, container);
    }
}

// Modify the renderConfigurationForm function to use this new handler
function renderConfigurationForm(configData) {
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    dynamicFieldsContainer.innerHTML = ''; // Clear existing fields

    // Create input handler
    const inputHandler = new ConfigInputHandler('#dynamicFields');

    // Render fields based on config data
    Object.entries(configData).forEach(([fieldName, fieldConfig]) => {
        if (fieldConfig.show) {
            const dynamicInput = inputHandler.createDynamicInput(fieldName, fieldConfig);
            dynamicFieldsContainer.appendChild(dynamicInput);
        }
    });

    // Show the form container
    document.getElementById('configFormContainer').style.display = 'block';
}