class ConfigInputHandler {
    constructor(containerSelector) {
        this.container = document.querySelector(containerSelector);
        this.inputTypes = {
            STRING: 'string',
            ARRAY: 'array',
            OBJECT: 'object',
            BOOLEAN: 'boolean',
            NUMBER: 'number'
        };
    }

    // Recursive type detection for nested structures
    detectInputType(value) {
        if (Array.isArray(value)) {
            // Check if it's a nested array or array of complex objects
            if (value.length > 0) {
                const firstItem = value[0];
                if (typeof firstItem === 'object' && firstItem !== null) {
                    return this.inputTypes.ARRAY; // Nested array or array of objects
                }
            }
            return this.inputTypes.ARRAY;
        }
        
        if (typeof value === 'object' && value !== null) {
            return this.inputTypes.OBJECT;
        }
        
        if (typeof value === 'boolean') return this.inputTypes.BOOLEAN;
        if (typeof value === 'number') return this.inputTypes.NUMBER;
        
        return this.inputTypes.STRING;
    }

    // Recursive input creation for nested structures
    createInputBasedOnType(type, defaultValue, depth = 0) {
        const maxDepth = 3; // Prevent excessive nesting
        if (depth > maxDepth) {
            console.warn('Maximum nesting depth reached');
            return this.createStringInput(JSON.stringify(defaultValue), () => {});
        }

        const onChangeCallback = (value) => {
            console.log('Value changed:', value);
        };

        switch(type) {
            case this.inputTypes.STRING:
                return this.createStringInput(defaultValue, onChangeCallback);
            
            case this.inputTypes.ARRAY:
                return this.createNestedArrayInput(defaultValue, onChangeCallback, depth);
            
            case this.inputTypes.OBJECT:
                return this.createNestedObjectInput(defaultValue, onChangeCallback, depth);
            
            case this.inputTypes.BOOLEAN:
                return this.createBooleanInput(defaultValue, onChangeCallback);
            
            case this.inputTypes.NUMBER:
                return this.createNumberInput(defaultValue, onChangeCallback);
            
            default:
                return this.createStringInput(defaultValue, onChangeCallback);
        }
    }

    // Enhanced array input to handle nested arrays
    createNestedArrayInput(defaultValue, onChangeCallback, depth) {
        const container = document.createElement('div');
        container.className = 'nested-array-container';

        // Ensure defaultValue is an array
        const arrayValues = Array.isArray(defaultValue) ? [...defaultValue] : [];

        const renderArrayItems = () => {
            container.innerHTML = ''; // Clear existing items
            
            arrayValues.forEach((value, index) => {
                const itemWrapper = document.createElement('div');
                itemWrapper.className = 'nested-array-item input-group mb-2';

                // Detect type for this specific array item
                const itemType = this.detectInputType(value);

                // Input type selector for nested items
                const typeSelector = this.createInputTypeSelector(itemType, (newType) => {
                    // Reset the value based on the new type
                    switch(newType) {
                        case this.inputTypes.STRING:
                            arrayValues[index] = '';
                            break;
                        case this.inputTypes.NUMBER:
                            arrayValues[index] = 0;
                            break;
                        case this.inputTypes.BOOLEAN:
                            arrayValues[index] = false;
                            break;
                        case this.inputTypes.ARRAY:
                            arrayValues[index] = [];
                            break;
                        case this.inputTypes.OBJECT:
                            arrayValues[index] = {};
                            break;
                    }
                    renderArrayItems();
                    onChangeCallback(arrayValues);
                });

                // Create input based on detected type
                const itemInput = this.createInputBasedOnType(itemType, value, depth + 1);

                // Event listener to update value
                if (itemInput) {
                    itemInput.addEventListener('change', (e) => {
                        arrayValues[index] = e.target.value;
                        onChangeCallback(arrayValues);
                    });
                }

                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-danger ms-2';
                removeBtn.innerHTML = '&times;';
                removeBtn.type = 'button';
                removeBtn.addEventListener('click', () => {
                    arrayValues.splice(index, 1);
                    renderArrayItems();
                    onChangeCallback(arrayValues);
                });

                // Assemble item
                itemWrapper.appendChild(typeSelector);
                itemWrapper.appendChild(itemInput);
                itemWrapper.appendChild(removeBtn);

                container.appendChild(itemWrapper);
            });

            // Add new item button
            const addBtn = document.createElement('button');
            addBtn.className = 'btn btn-primary mt-2';
            addBtn.textContent = 'Add Item';
            addBtn.type = 'button';
            addBtn.addEventListener('click', () => {
                arrayValues.push(''); // Default to empty string
                renderArrayItems();
                onChangeCallback(arrayValues);
            });

            container.appendChild(addBtn);
        };

        renderArrayItems();
        return container;
    }

    // Enhanced object input to handle nested objects
    createNestedObjectInput(defaultValue, onChangeCallback, depth) {
        const container = document.createElement('div');
        container.className = 'nested-object-container';

        // Ensure defaultValue is an object
        const objectValues = typeof defaultValue === 'object' && defaultValue !== null 
            ? Object.entries(defaultValue).map(([k, v]) => ({ key: k, value: v })) 
            : [];

        const renderObjectItems = () => {
            container.innerHTML = ''; // Clear existing items
            
            objectValues.forEach((item, index) => {
                const itemWrapper = document.createElement('div');
                itemWrapper.className = 'nested-object-item input-group mb-2';

                // Key input
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.className = 'form-control me-2';
                keyInput.placeholder = 'Key';
                keyInput.value = item.key;

                // Detect type for this specific object value
                const valueType = this.detectInputType(item.value);

                // Input type selector for nested values
                const typeSelector = this.createInputTypeSelector(valueType, (newType) => {
                    // Reset the value based on the new type
                    switch(newType) {
                        case this.inputTypes.STRING:
                            objectValues[index].value = '';
                            break;
                        case this.inputTypes.NUMBER:
                            objectValues[index].value = 0;
                            break;
                        case this.inputTypes.BOOLEAN:
                            objectValues[index].value = false;
                            break;
                        case this.inputTypes.ARRAY:
                            objectValues[index].value = [];
                            break;
                        case this.inputTypes.OBJECT:
                            objectValues[index].value = {};
                            break;
                    }
                    renderObjectItems();
                    onChangeCallback(objectValues.reduce((acc, curr) => {
                        if (curr.key) acc[curr.key] = curr.value;
                        return acc;
                    }, {}));
                });

                // Create value input based on detected type
                const valueInput = this.createInputBasedOnType(valueType, item.value, depth + 1);

                // Update key and value events
                keyInput.addEventListener('input', (e) => {
                    objectValues[index].key = e.target.value;
                    onChangeCallback(objectValues.reduce((acc, curr) => {
                        if (curr.key) acc[curr.key] = curr.value;
                        return acc;
                    }, {}));
                });

                if (valueInput) {
                    valueInput.addEventListener('change', (e) => {
                        objectValues[index].value = e.target.value;
                        onChangeCallback(objectValues.reduce((acc, curr) => {
                            if (curr.key) acc[curr.key] = curr.value;
                            return acc;
                        }, {}));
                    });
                }

                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-danger ms-2';
                removeBtn.innerHTML = '&times;';
                removeBtn.addEventListener('click', () => {
                    objectValues.splice(index, 1);
                    renderObjectItems();
                    onChangeCallback(objectValues.reduce((acc, curr) => {
                        if (curr.key) acc[curr.key] = curr.value;
                        return acc;
                    }, {}));
                });

                // Assemble item
                itemWrapper.appendChild(keyInput);
                itemWrapper.appendChild(typeSelector);
                itemWrapper.appendChild(valueInput);
                itemWrapper.appendChild(removeBtn);

                container.appendChild(itemWrapper);
            });

            // Add new item button
            const addBtn = document.createElement('button');
            addBtn.className = 'btn btn-primary mt-2';
            addBtn.textContent = 'Add Key-Value Pair';
            addBtn.addEventListener('click', () => {
                objectValues.push({ key: '', value: '' });
                renderObjectItems();
            });

            container.appendChild(addBtn);
        };

        renderObjectItems();
        return container;
    }

    // Rest of the methods remain the same as in the previous implementation...
    // (createInputTypeSelector, createStringInput, createBooleanInput, etc.)
}