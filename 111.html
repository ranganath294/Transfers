// Recursive type detection with better complex type handling
detectInputType(value) {
    if (value === null) return this.inputTypes.STRING;
    
    if (Array.isArray(value)) {
        // Check first item to determine array type
        if (value.length === 0) return this.inputTypes.ARRAY;
        
        const firstItem = value[0];
        const itemType = this.detectItemType(firstItem);
        return `${this.inputTypes.ARRAY}_of_${itemType}`;
    }
    
    if (typeof value === 'object') {
        // Check if it's a plain object with nested structures
        const objectEntries = Object.entries(value);
        if (objectEntries.length === 0) return this.inputTypes.OBJECT;
        
        // Check if any value is complex
        const hasComplexValue = objectEntries.some(([_, val]) => 
            Array.isArray(val) || (typeof val === 'object' && val !== null)
        );
        
        return hasComplexValue ? `${this.inputTypes.OBJECT}_with_complex_values` : this.inputTypes.OBJECT;
    }
    
    if (typeof value === 'boolean') return this.inputTypes.BOOLEAN;
    if (typeof value === 'number') return this.inputTypes.NUMBER;
    
    return this.inputTypes.STRING;
}

// New method to detect individual item type
detectItemType(item) {
    if (item === null) return 'primitive';
    if (Array.isArray(item)) return this.inputTypes.ARRAY;
    if (typeof item === 'object') return this.inputTypes.OBJECT;
    return typeof item;
}

// Enhanced input creation to handle complex nested types
createInputBasedOnType(type, defaultValue, depth = 0) {
    const MAX_DEPTH = 3;
    if (depth > MAX_DEPTH) {
        console.warn('Maximum nesting depth reached');
        return this.createStringInput(JSON.stringify(defaultValue), () => {});
    }

    const onChangeCallback = (value) => {
        console.log('Value changed:', value);
    };

    // Handle array of specific types
    if (type.startsWith(`${this.inputTypes.ARRAY}_of_`)) {
        const itemType = type.split('_of_')[1];
        return this.createNestedArrayInput(
            defaultValue, 
            onChangeCallback, 
            depth, 
            itemType
        );
    }

    // Handle complex nested objects
    if (type === `${this.inputTypes.OBJECT}_with_complex_values`) {
        return this.createNestedObjectInput(
            defaultValue, 
            onChangeCallback, 
            depth
        );
    }

    // Original type handling remains the same
    switch(type) {
        case this.inputTypes.STRING:
            return this.createStringInput(defaultValue, onChangeCallback);
        case this.inputTypes.ARRAY:
            return this.createNestedArrayInput(defaultValue, onChangeCallback, depth);
        case this.inputTypes.OBJECT:
            return this.createNestedObjectInput(defaultValue, onChangeCallback, depth);
        case this.inputTypes.BOOLEAN:
            return this.createBooleanInput(defaultValue, onChangeCallback);
        case this.inputTypes.NUMBER:
            return this.createNumberInput(defaultValue, onChangeCallback);
        default:
            return this.createStringInput(defaultValue, onChangeCallback);
    }
}

// Enhanced nested array input with explicit item type
createNestedArrayInput(defaultValue, onChangeCallback, depth, itemType = null) {
    const container = document.createElement('div');
    container.className = 'nested-array-container';

    const arrayValues = Array.isArray(defaultValue) ? [...defaultValue] : [];

    const renderArrayItems = () => {
        container.innerHTML = '';
        
        arrayValues.forEach((value, index) => {
            const itemWrapper = document.createElement('div');
            itemWrapper.className = 'nested-array-item input-group mb-2';

            // Use provided or detect item type
            const currentItemType = itemType || this.detectItemType(value);

            // Input based on detected/provided type
            const itemInput = this.createInputBasedOnType(
                currentItemType === 'primitive' 
                    ? this.detectInputType(value) 
                    : currentItemType, 
                value, 
                depth + 1
            );

            // Update value handling
            itemInput.addEventListener('change', (e) => {
                arrayValues[index] = e.target.value;
                onChangeCallback(arrayValues);
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger ms-2';
            removeBtn.innerHTML = '&times;';
            removeBtn.addEventListener('click', () => {
                arrayValues.splice(index, 1);
                renderArrayItems();
                onChangeCallback(arrayValues);
            });

            itemWrapper.appendChild(itemInput);
            itemWrapper.appendChild(removeBtn);

            container.appendChild(itemWrapper);
        });

        // Add new item button
        const addBtn = document.createElement('button');
        addBtn.className = 'btn btn-primary mt-2';
        addBtn.textContent = 'Add Item';
        addBtn.addEventListener('click', () => {
            arrayValues.push(''); // Default to empty string
            renderArrayItems();
            onChangeCallback(arrayValues);
        });

        container.appendChild(addBtn);
    };

    renderArrayItems();
    return container;
}